/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CustomerEntity,
  CustomerEntity$inboundSchema,
  CustomerEntity$Outbound,
  CustomerEntity$outboundSchema,
} from "./customerentity.js";
import {
  ProductEntity,
  ProductEntity$inboundSchema,
  ProductEntity$Outbound,
  ProductEntity$outboundSchema,
} from "./productentity.js";
import {
  SubscriptionItemEntity,
  SubscriptionItemEntity$inboundSchema,
  SubscriptionItemEntity$Outbound,
  SubscriptionItemEntity$outboundSchema,
} from "./subscriptionitementity.js";
import {
  TransactionEntity,
  TransactionEntity$inboundSchema,
  TransactionEntity$Outbound,
  TransactionEntity$outboundSchema,
} from "./transactionentity.js";

/**
 * String representing the environment.
 */
export const SubscriptionEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox",
} as const;
/**
 * String representing the environment.
 */
export type SubscriptionEntityMode = ClosedEnum<typeof SubscriptionEntityMode>;

/**
 * The product associated with the subscription.
 */
export type Product = ProductEntity | string;

/**
 * The customer who owns the subscription.
 */
export type Customer = CustomerEntity | string;

/**
 * The current status of the subscription.
 */
export const Status = {
  Active: "active",
  Canceled: "canceled",
  Unpaid: "unpaid",
  Paused: "paused",
  Trialing: "trialing",
} as const;
/**
 * The current status of the subscription.
 */
export type Status = ClosedEnum<typeof Status>;

export type SubscriptionEntity = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: SubscriptionEntityMode;
  /**
   * String representing the object's type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * The product associated with the subscription.
   */
  product: ProductEntity | string;
  /**
   * The customer who owns the subscription.
   */
  customer: CustomerEntity | string;
  /**
   * Subscription items.
   */
  items?: Array<SubscriptionItemEntity> | undefined;
  /**
   * The method used for collecting payments for the subscription.
   */
  collectionMethod: string;
  /**
   * The current status of the subscription.
   */
  status: Status;
  /**
   * The ID of the last paid transaction.
   */
  lastTransactionId?: string | undefined;
  /**
   * The last paid transaction.
   */
  lastTransaction?: TransactionEntity | undefined;
  /**
   * The date of the last paid transaction.
   */
  lastTransactionDate?: Date | undefined;
  /**
   * The date when the next subscription transaction will be charged.
   */
  nextTransactionDate?: Date | undefined;
  /**
   * The start date of the current subscription period.
   */
  currentPeriodStartDate?: Date | undefined;
  /**
   * The end date of the current subscription period.
   */
  currentPeriodEndDate?: Date | undefined;
  /**
   * The date and time when the subscription was canceled, if applicable.
   */
  canceledAt?: Date | null | undefined;
  /**
   * The date and time when the subscription was created.
   */
  createdAt: Date;
  /**
   * The date and time when the subscription was last updated.
   */
  updatedAt: Date;
};

/** @internal */
export const SubscriptionEntityMode$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionEntityMode
> = z.nativeEnum(SubscriptionEntityMode);

/** @internal */
export const SubscriptionEntityMode$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionEntityMode
> = SubscriptionEntityMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionEntityMode$ {
  /** @deprecated use `SubscriptionEntityMode$inboundSchema` instead. */
  export const inboundSchema = SubscriptionEntityMode$inboundSchema;
  /** @deprecated use `SubscriptionEntityMode$outboundSchema` instead. */
  export const outboundSchema = SubscriptionEntityMode$outboundSchema;
}

/** @internal */
export const Product$inboundSchema: z.ZodType<Product, z.ZodTypeDef, unknown> =
  z.union([ProductEntity$inboundSchema, z.string()]);

/** @internal */
export type Product$Outbound = ProductEntity$Outbound | string;

/** @internal */
export const Product$outboundSchema: z.ZodType<
  Product$Outbound,
  z.ZodTypeDef,
  Product
> = z.union([ProductEntity$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Product$ {
  /** @deprecated use `Product$inboundSchema` instead. */
  export const inboundSchema = Product$inboundSchema;
  /** @deprecated use `Product$outboundSchema` instead. */
  export const outboundSchema = Product$outboundSchema;
  /** @deprecated use `Product$Outbound` instead. */
  export type Outbound = Product$Outbound;
}

export function productToJSON(product: Product): string {
  return JSON.stringify(Product$outboundSchema.parse(product));
}

export function productFromJSON(
  jsonString: string,
): SafeParseResult<Product, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Product$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Product' from JSON`,
  );
}

/** @internal */
export const Customer$inboundSchema: z.ZodType<
  Customer,
  z.ZodTypeDef,
  unknown
> = z.union([CustomerEntity$inboundSchema, z.string()]);

/** @internal */
export type Customer$Outbound = CustomerEntity$Outbound | string;

/** @internal */
export const Customer$outboundSchema: z.ZodType<
  Customer$Outbound,
  z.ZodTypeDef,
  Customer
> = z.union([CustomerEntity$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Customer$ {
  /** @deprecated use `Customer$inboundSchema` instead. */
  export const inboundSchema = Customer$inboundSchema;
  /** @deprecated use `Customer$outboundSchema` instead. */
  export const outboundSchema = Customer$outboundSchema;
  /** @deprecated use `Customer$Outbound` instead. */
  export type Outbound = Customer$Outbound;
}

export function customerToJSON(customer: Customer): string {
  return JSON.stringify(Customer$outboundSchema.parse(customer));
}

export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const SubscriptionEntity$inboundSchema: z.ZodType<
  SubscriptionEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: SubscriptionEntityMode$inboundSchema,
  object: z.string(),
  product: z.union([ProductEntity$inboundSchema, z.string()]),
  customer: z.union([CustomerEntity$inboundSchema, z.string()]),
  items: z.array(SubscriptionItemEntity$inboundSchema).optional(),
  collection_method: z.string(),
  status: Status$inboundSchema,
  last_transaction_id: z.string().optional(),
  last_transaction: TransactionEntity$inboundSchema.optional(),
  last_transaction_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  next_transaction_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  current_period_start_date: z.string().datetime({ offset: true }).transform(
    v => new Date(v)
  ).optional(),
  current_period_end_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  canceled_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v)),
}).transform((v) => {
  return remap$(v, {
    "collection_method": "collectionMethod",
    "last_transaction_id": "lastTransactionId",
    "last_transaction": "lastTransaction",
    "last_transaction_date": "lastTransactionDate",
    "next_transaction_date": "nextTransactionDate",
    "current_period_start_date": "currentPeriodStartDate",
    "current_period_end_date": "currentPeriodEndDate",
    "canceled_at": "canceledAt",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
  });
});

/** @internal */
export type SubscriptionEntity$Outbound = {
  id: string;
  mode: string;
  object: string;
  product: ProductEntity$Outbound | string;
  customer: CustomerEntity$Outbound | string;
  items?: Array<SubscriptionItemEntity$Outbound> | undefined;
  collection_method: string;
  status: string;
  last_transaction_id?: string | undefined;
  last_transaction?: TransactionEntity$Outbound | undefined;
  last_transaction_date?: string | undefined;
  next_transaction_date?: string | undefined;
  current_period_start_date?: string | undefined;
  current_period_end_date?: string | undefined;
  canceled_at?: string | null | undefined;
  created_at: string;
  updated_at: string;
};

/** @internal */
export const SubscriptionEntity$outboundSchema: z.ZodType<
  SubscriptionEntity$Outbound,
  z.ZodTypeDef,
  SubscriptionEntity
> = z.object({
  id: z.string(),
  mode: SubscriptionEntityMode$outboundSchema,
  object: z.string(),
  product: z.union([ProductEntity$outboundSchema, z.string()]),
  customer: z.union([CustomerEntity$outboundSchema, z.string()]),
  items: z.array(SubscriptionItemEntity$outboundSchema).optional(),
  collectionMethod: z.string(),
  status: Status$outboundSchema,
  lastTransactionId: z.string().optional(),
  lastTransaction: TransactionEntity$outboundSchema.optional(),
  lastTransactionDate: z.date().transform(v => v.toISOString()).optional(),
  nextTransactionDate: z.date().transform(v => v.toISOString()).optional(),
  currentPeriodStartDate: z.date().transform(v => v.toISOString()).optional(),
  currentPeriodEndDate: z.date().transform(v => v.toISOString()).optional(),
  canceledAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  updatedAt: z.date().transform(v => v.toISOString()),
}).transform((v) => {
  return remap$(v, {
    collectionMethod: "collection_method",
    lastTransactionId: "last_transaction_id",
    lastTransaction: "last_transaction",
    lastTransactionDate: "last_transaction_date",
    nextTransactionDate: "next_transaction_date",
    currentPeriodStartDate: "current_period_start_date",
    currentPeriodEndDate: "current_period_end_date",
    canceledAt: "canceled_at",
    createdAt: "created_at",
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionEntity$ {
  /** @deprecated use `SubscriptionEntity$inboundSchema` instead. */
  export const inboundSchema = SubscriptionEntity$inboundSchema;
  /** @deprecated use `SubscriptionEntity$outboundSchema` instead. */
  export const outboundSchema = SubscriptionEntity$outboundSchema;
  /** @deprecated use `SubscriptionEntity$Outbound` instead. */
  export type Outbound = SubscriptionEntity$Outbound;
}

export function subscriptionEntityToJSON(
  subscriptionEntity: SubscriptionEntity,
): string {
  return JSON.stringify(
    SubscriptionEntity$outboundSchema.parse(subscriptionEntity),
  );
}

export function subscriptionEntityFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionEntity' from JSON`,
  );
}
