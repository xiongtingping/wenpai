"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatResult = formatResult;
exports.createRegisterTool = createRegisterTool;
const shared_js_1 = require("./shared.js");
// Optional function to assist with formatting tool results
async function formatResult(value, init) {
    if (typeof value === "undefined") {
        return { content: [] };
    }
    const { response } = init;
    const contentType = response?.headers.get("content-type") ?? "";
    let content = [];
    if (contentType.search(/\bjson\b/g)) {
        content = [{ type: "text", text: JSON.stringify(value) }];
    }
    else if (contentType.startsWith("text/event-stream")
        && (0, shared_js_1.isAsyncIterable)(value)) {
        content = await consumeSSE(value);
    }
    else if (contentType.startsWith("text/") && typeof value === "string") {
        content = [{ type: "text", text: value }];
    }
    else if ((0, shared_js_1.isBinaryData)(value) && contentType.startsWith("image/")) {
        const data = await (0, shared_js_1.valueToBase64)(value);
        content = data == null
            ? []
            : [{ type: "image", data, mimeType: contentType }];
    }
    else {
        return {
            content: [{
                    type: "text",
                    text: `Unsupported content type: "${contentType}"`,
                }],
            isError: true,
        };
    }
    return { content };
}
async function consumeSSE(value) {
    const content = [];
    for await (const chunk of value) {
        if (typeof chunk === "string") {
            content.push({ type: "text", text: chunk });
        }
        else {
            content.push({ type: "text", text: JSON.stringify(chunk) });
        }
    }
    return content;
}
function createRegisterTool(logger, server, sdk, allowedScopes, allowedTools) {
    return (tool) => {
        if (allowedTools && !allowedTools.has(tool.name)) {
            return;
        }
        const scopes = tool.scopes ?? [];
        if (allowedScopes.size > 0 && scopes.length === 0) {
            return;
        }
        if (allowedScopes.size > 0
            && !scopes.every((s) => allowedScopes.has(s))) {
            return;
        }
        if (tool.args) {
            server.tool(tool.name, tool.description, tool.args, async (args, ctx) => {
                return tool.tool(sdk, args, ctx);
            });
        }
        else {
            server.tool(tool.name, tool.description, async (ctx) => {
                return tool.tool(sdk, ctx);
            });
        }
        logger.debug("Registered tool", { name: tool.name });
    };
}
//# sourceMappingURL=tools.js.map