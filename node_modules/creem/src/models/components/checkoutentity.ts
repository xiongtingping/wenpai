/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CustomerEntity,
  CustomerEntity$inboundSchema,
  CustomerEntity$Outbound,
  CustomerEntity$outboundSchema,
} from "./customerentity.js";
import {
  CustomField,
  CustomField$inboundSchema,
  CustomField$Outbound,
  CustomField$outboundSchema,
} from "./customfield.js";
import {
  OrderEntity,
  OrderEntity$inboundSchema,
  OrderEntity$Outbound,
  OrderEntity$outboundSchema,
} from "./orderentity.js";
import {
  ProductEntity,
  ProductEntity$inboundSchema,
  ProductEntity$Outbound,
  ProductEntity$outboundSchema,
} from "./productentity.js";
import {
  ProductFeatureEntity,
  ProductFeatureEntity$inboundSchema,
  ProductFeatureEntity$Outbound,
  ProductFeatureEntity$outboundSchema,
} from "./productfeatureentity.js";
import {
  SubscriptionEntity,
  SubscriptionEntity$inboundSchema,
  SubscriptionEntity$Outbound,
  SubscriptionEntity$outboundSchema,
} from "./subscriptionentity.js";

/**
 * String representing the environment.
 */
export const CheckoutEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox",
} as const;
/**
 * String representing the environment.
 */
export type CheckoutEntityMode = ClosedEnum<typeof CheckoutEntityMode>;

/**
 * The product associated with the checkout session.
 */
export type CheckoutEntityProduct = ProductEntity | string;

/**
 * The subscription associated with the checkout session.
 */
export type Subscription = SubscriptionEntity | string;

/**
 * The customer associated with the checkout session.
 */
export type CheckoutEntityCustomer = CustomerEntity | string;

export type CheckoutEntity = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * String representing the environment.
   */
  mode: CheckoutEntityMode;
  /**
   * String representing the object's type. Objects of the same type share the same value.
   */
  object: string;
  /**
   * Status of the checkout.
   */
  status: string;
  /**
   * Identify and track each checkout request.
   */
  requestId?: string | undefined;
  /**
   * The product associated with the checkout session.
   */
  product: ProductEntity | string;
  /**
   * The number of units for the of the product.
   */
  units?: number | undefined;
  /**
   * The order associated with the checkout session.
   */
  order?: OrderEntity | undefined;
  /**
   * The subscription associated with the checkout session.
   */
  subscription?: SubscriptionEntity | string | undefined;
  /**
   * The customer associated with the checkout session.
   */
  customer?: CustomerEntity | string | undefined;
  /**
   * Additional information collected from your customer during the checkout process.
   */
  customFields?: Array<CustomField> | undefined;
  /**
   * The URL to which the customer will be redirected to complete the payment.
   */
  checkoutUrl?: string | undefined;
  /**
   * The URL to which the user will be redirected after the checkout process is completed.
   */
  successUrl?: string | null | undefined;
  /**
   * Features issued for the order.
   */
  feature?: Array<ProductFeatureEntity> | undefined;
  /**
   * Metadata for the checkout in the form of key-value pairs
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CheckoutEntityMode$inboundSchema: z.ZodNativeEnum<
  typeof CheckoutEntityMode
> = z.nativeEnum(CheckoutEntityMode);

/** @internal */
export const CheckoutEntityMode$outboundSchema: z.ZodNativeEnum<
  typeof CheckoutEntityMode
> = CheckoutEntityMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckoutEntityMode$ {
  /** @deprecated use `CheckoutEntityMode$inboundSchema` instead. */
  export const inboundSchema = CheckoutEntityMode$inboundSchema;
  /** @deprecated use `CheckoutEntityMode$outboundSchema` instead. */
  export const outboundSchema = CheckoutEntityMode$outboundSchema;
}

/** @internal */
export const CheckoutEntityProduct$inboundSchema: z.ZodType<
  CheckoutEntityProduct,
  z.ZodTypeDef,
  unknown
> = z.union([ProductEntity$inboundSchema, z.string()]);

/** @internal */
export type CheckoutEntityProduct$Outbound = ProductEntity$Outbound | string;

/** @internal */
export const CheckoutEntityProduct$outboundSchema: z.ZodType<
  CheckoutEntityProduct$Outbound,
  z.ZodTypeDef,
  CheckoutEntityProduct
> = z.union([ProductEntity$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckoutEntityProduct$ {
  /** @deprecated use `CheckoutEntityProduct$inboundSchema` instead. */
  export const inboundSchema = CheckoutEntityProduct$inboundSchema;
  /** @deprecated use `CheckoutEntityProduct$outboundSchema` instead. */
  export const outboundSchema = CheckoutEntityProduct$outboundSchema;
  /** @deprecated use `CheckoutEntityProduct$Outbound` instead. */
  export type Outbound = CheckoutEntityProduct$Outbound;
}

export function checkoutEntityProductToJSON(
  checkoutEntityProduct: CheckoutEntityProduct,
): string {
  return JSON.stringify(
    CheckoutEntityProduct$outboundSchema.parse(checkoutEntityProduct),
  );
}

export function checkoutEntityProductFromJSON(
  jsonString: string,
): SafeParseResult<CheckoutEntityProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckoutEntityProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckoutEntityProduct' from JSON`,
  );
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<
  Subscription,
  z.ZodTypeDef,
  unknown
> = z.union([SubscriptionEntity$inboundSchema, z.string()]);

/** @internal */
export type Subscription$Outbound = SubscriptionEntity$Outbound | string;

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
  Subscription$Outbound,
  z.ZodTypeDef,
  Subscription
> = z.union([SubscriptionEntity$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
  /** @deprecated use `Subscription$inboundSchema` instead. */
  export const inboundSchema = Subscription$inboundSchema;
  /** @deprecated use `Subscription$outboundSchema` instead. */
  export const outboundSchema = Subscription$outboundSchema;
  /** @deprecated use `Subscription$Outbound` instead. */
  export type Outbound = Subscription$Outbound;
}

export function subscriptionToJSON(subscription: Subscription): string {
  return JSON.stringify(Subscription$outboundSchema.parse(subscription));
}

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}

/** @internal */
export const CheckoutEntityCustomer$inboundSchema: z.ZodType<
  CheckoutEntityCustomer,
  z.ZodTypeDef,
  unknown
> = z.union([CustomerEntity$inboundSchema, z.string()]);

/** @internal */
export type CheckoutEntityCustomer$Outbound = CustomerEntity$Outbound | string;

/** @internal */
export const CheckoutEntityCustomer$outboundSchema: z.ZodType<
  CheckoutEntityCustomer$Outbound,
  z.ZodTypeDef,
  CheckoutEntityCustomer
> = z.union([CustomerEntity$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckoutEntityCustomer$ {
  /** @deprecated use `CheckoutEntityCustomer$inboundSchema` instead. */
  export const inboundSchema = CheckoutEntityCustomer$inboundSchema;
  /** @deprecated use `CheckoutEntityCustomer$outboundSchema` instead. */
  export const outboundSchema = CheckoutEntityCustomer$outboundSchema;
  /** @deprecated use `CheckoutEntityCustomer$Outbound` instead. */
  export type Outbound = CheckoutEntityCustomer$Outbound;
}

export function checkoutEntityCustomerToJSON(
  checkoutEntityCustomer: CheckoutEntityCustomer,
): string {
  return JSON.stringify(
    CheckoutEntityCustomer$outboundSchema.parse(checkoutEntityCustomer),
  );
}

export function checkoutEntityCustomerFromJSON(
  jsonString: string,
): SafeParseResult<CheckoutEntityCustomer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckoutEntityCustomer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckoutEntityCustomer' from JSON`,
  );
}

/** @internal */
export const CheckoutEntity$inboundSchema: z.ZodType<
  CheckoutEntity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  mode: CheckoutEntityMode$inboundSchema,
  object: z.string(),
  status: z.string(),
  request_id: z.string().optional(),
  product: z.union([ProductEntity$inboundSchema, z.string()]),
  units: z.number().default(1),
  order: OrderEntity$inboundSchema.optional(),
  subscription: z.union([SubscriptionEntity$inboundSchema, z.string()])
    .optional(),
  customer: z.union([CustomerEntity$inboundSchema, z.string()]).optional(),
  custom_fields: z.array(CustomField$inboundSchema).optional(),
  checkout_url: z.string().optional(),
  success_url: z.nullable(z.string()).optional(),
  feature: z.array(ProductFeatureEntity$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "request_id": "requestId",
    "custom_fields": "customFields",
    "checkout_url": "checkoutUrl",
    "success_url": "successUrl",
  });
});

/** @internal */
export type CheckoutEntity$Outbound = {
  id: string;
  mode: string;
  object: string;
  status: string;
  request_id?: string | undefined;
  product: ProductEntity$Outbound | string;
  units: number;
  order?: OrderEntity$Outbound | undefined;
  subscription?: SubscriptionEntity$Outbound | string | undefined;
  customer?: CustomerEntity$Outbound | string | undefined;
  custom_fields?: Array<CustomField$Outbound> | undefined;
  checkout_url?: string | undefined;
  success_url?: string | null | undefined;
  feature?: Array<ProductFeatureEntity$Outbound> | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CheckoutEntity$outboundSchema: z.ZodType<
  CheckoutEntity$Outbound,
  z.ZodTypeDef,
  CheckoutEntity
> = z.object({
  id: z.string(),
  mode: CheckoutEntityMode$outboundSchema,
  object: z.string(),
  status: z.string(),
  requestId: z.string().optional(),
  product: z.union([ProductEntity$outboundSchema, z.string()]),
  units: z.number().default(1),
  order: OrderEntity$outboundSchema.optional(),
  subscription: z.union([SubscriptionEntity$outboundSchema, z.string()])
    .optional(),
  customer: z.union([CustomerEntity$outboundSchema, z.string()]).optional(),
  customFields: z.array(CustomField$outboundSchema).optional(),
  checkoutUrl: z.string().optional(),
  successUrl: z.nullable(z.string()).optional(),
  feature: z.array(ProductFeatureEntity$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    requestId: "request_id",
    customFields: "custom_fields",
    checkoutUrl: "checkout_url",
    successUrl: "success_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CheckoutEntity$ {
  /** @deprecated use `CheckoutEntity$inboundSchema` instead. */
  export const inboundSchema = CheckoutEntity$inboundSchema;
  /** @deprecated use `CheckoutEntity$outboundSchema` instead. */
  export const outboundSchema = CheckoutEntity$outboundSchema;
  /** @deprecated use `CheckoutEntity$Outbound` instead. */
  export type Outbound = CheckoutEntity$Outbound;
}

export function checkoutEntityToJSON(checkoutEntity: CheckoutEntity): string {
  return JSON.stringify(CheckoutEntity$outboundSchema.parse(checkoutEntity));
}

export function checkoutEntityFromJSON(
  jsonString: string,
): SafeParseResult<CheckoutEntity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CheckoutEntity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CheckoutEntity' from JSON`,
  );
}
