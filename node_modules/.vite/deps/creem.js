import {
  __export
} from "./chunk-VHXUCOYC.js";

// node_modules/creem/dist/esm/lib/url.js
var hasOwn = Object.prototype.hasOwnProperty;
function pathToFunc(pathPattern, options) {
  const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
  return function buildURLPath(params = {}) {
    return pathPattern.replace(paramRE, function(_, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }
      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Parameter '${placeholder}' must be a string or number`);
      }
      return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
    });
  };
}

// node_modules/creem/dist/esm/lib/config.js
var ServerList = [
  "https://api.creem.io",
  "https://test-api.creem.io",
  "http://localhost:8000"
];
function serverURLFromOptions(options) {
  let serverURL = options.serverURL;
  const params = {};
  if (!serverURL) {
    const serverIdx = options.serverIdx ?? 0;
    if (serverIdx < 0 || serverIdx >= ServerList.length) {
      throw new Error(`Invalid server index ${serverIdx}`);
    }
    serverURL = ServerList[serverIdx] || "";
  }
  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}
var SDK_METADATA = {
  language: "typescript",
  openapiDocVersion: "v1",
  sdkVersion: "0.3.37",
  genVersion: "2.599.0",
  userAgent: "speakeasy-sdk/typescript 0.3.37 2.599.0 v1 creem"
};

// node_modules/creem/dist/esm/lib/files.js
var files_exports = {};
__export(files_exports, {
  readableStreamToArrayBuffer: () => readableStreamToArrayBuffer
});
async function readableStreamToArrayBuffer(readable) {
  const reader = readable.getReader();
  const chunks = [];
  let totalLength = 0;
  let done = false;
  while (!done) {
    const { value, done: doneReading } = await reader.read();
    if (doneReading) {
      done = true;
    } else {
      chunks.push(value);
      totalLength += value.length;
    }
  }
  const concatenatedChunks = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    concatenatedChunks.set(chunk, offset);
    offset += chunk.length;
  }
  return concatenatedChunks.buffer;
}

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 10
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
        } else {
          handlePropertyResult(r, payload, key, input);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (left.issues.length) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}

// node_modules/zod/v4/classic/iso.js
var ZodISODateTime = $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = _parse(ZodRealError);
var parseAsync2 = _parseAsync(ZodRealError);
var safeParse2 = _safeParse(ZodRealError);
var safeParseAsync2 = _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodURL = $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodEmoji = $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCustomStringFormat = $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNumber = $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
var ZodBoolean = $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
var ZodBigIntFormat = $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
var ZodSymbol = $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
var ZodUndefined = $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
var ZodNull = $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
var ZodAny = $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
var ZodDate = $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
var ZodObject = $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
var ZodUnion = $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
var ZodIntersection = $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
var ZodRecord = $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
var ZodSet = $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
var ZodEnum = $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
var ZodFile = $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
var ZodTransform = $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
var ZodDefault = $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
var ZodCatch = $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
var ZodPipe = $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
var ZodLazy = $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
var ZodCustom = $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}

// node_modules/zod/v4/classic/compat.js
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint2(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/creem/dist/esm/lib/base64.js
function bytesToBase64(u8arr) {
  return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function stringToBase64(str) {
  return bytesToBase64(stringToBytes(str));
}
var zodOutbound = _instanceof(Uint8Array).or(string2().transform(stringToBytes));
var zodInbound = _instanceof(Uint8Array).or(string2().transform(bytesFromBase64));

// node_modules/creem/dist/esm/lib/is-plain-object.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/creem/dist/esm/lib/encodings.js
var EncodingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EncodingError";
  }
};
function formEncoder(sep) {
  return (key, value, options) => {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [[key, value]];
    if (pairs.every(([_, v]) => v == null)) {
      return;
    }
    const encodeString = (v) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v) => encodeString(serializeValue(v));
    const encodedSep = encodeString(sep);
    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      let encValue = null;
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(encodedSep);
      } else if (isPlainObject2(pv)) {
        encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
        })?.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }
      if (encValue == null) {
        return;
      }
      tmp = `${encodeString(pk)}=${encValue}`;
      if (!tmp || tmp === "=") {
        return;
      }
      out += `&${tmp}`;
    });
    return out.slice(1);
  };
}
var encodeForm = formEncoder(",");
var encodeSpaceDelimited = formEncoder(" ");
var encodePipeDelimited = formEncoder("|");
function encodeDeepObject(key, value, options) {
  if (value == null) {
    return;
  }
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
  }
  return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
  if (value == null) {
    return;
  }
  let out = "";
  const encodeString = (v) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  if (!isPlainObject2(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }
  Object.entries(value).forEach(([ck, cv]) => {
    if (cv == null) {
      return;
    }
    const pk = `${key}[${ck}]`;
    if (isPlainObject2(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);
      out += objOut == null ? "" : `&${objOut}`;
      return;
    }
    const pairs = Array.isArray(cv) ? cv : [cv];
    const encoded = mapDefined(pairs, (v) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
    })?.join("&");
    out += encoded == null ? "" : `&${encoded}`;
  });
  return out.slice(1);
}
function encodeJSON(key, value, options) {
  if (typeof value === "undefined") {
    return;
  }
  const encodeString = (v) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encVal = encodeString(JSON.stringify(value, jsonReplacer));
  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}
var encodeSimple = (key, value, options) => {
  let out = "";
  const pairs = options?.explode ? explode(key, value) : [[key, value]];
  if (pairs.every(([_, v]) => v == null)) {
    return;
  }
  const encodeString = (v) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encodeValue = (v) => encodeString(serializeValue(v));
  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      tmp = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(",");
    } else if (isPlainObject2(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
        return `,${encodeString(k)},${encodeValue(v)}`;
      });
      tmp = mapped?.join("").slice(1);
    } else {
      const k = options?.explode && isPlainObject2(value) ? `${pk}=` : "";
      tmp = `${k}${encodeValue(pv)}`;
    }
    out += tmp ? `,${tmp}` : "";
  });
  return out.slice(1);
};
function explode(key, value) {
  if (Array.isArray(value)) {
    return value.map((v) => [key, v]);
  } else if (isPlainObject2(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k, v]) => [k, v]);
  } else {
    return [[key, value]];
  }
}
function serializeValue(value) {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }
  return `${value}`;
}
function jsonReplacer(_, value) {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}
function mapDefined(inp, mapper) {
  const res = inp.reduce((acc, v) => {
    if (v == null) {
      return acc;
    }
    const m = mapper(v);
    if (m == null) {
      return acc;
    }
    acc.push(m);
    return acc;
  }, []);
  return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
  const acc = [];
  for (const [k, v] of inp) {
    if (v == null) {
      continue;
    }
    const m = mapper([k, v]);
    if (m == null) {
      continue;
    }
    acc.push(m);
  }
  return acc.length ? acc : null;
}
function queryJoin(...args) {
  return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
  const bulkEncode = function(values, options) {
    const opts = {
      ...options,
      explode: options?.explode ?? true,
      charEncoding: options?.charEncoding ?? "percent"
    };
    const encoded = Object.entries(values).map(([key, value]) => {
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };
  return bulkEncode;
}
var encodeJSONQuery = queryEncoder(encodeJSON);
var encodeFormQuery = queryEncoder(encodeForm);
var encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
var encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
var encodeDeepObjectQuery = queryEncoder(encodeDeepObject);

// node_modules/creem/dist/esm/models/errors/apierror.js
var APIError = class extends Error {
  constructor(message, rawResponse, body = "") {
    const statusCode = rawResponse.status;
    const contentType = rawResponse.headers.get("content-type") || "";
    const bodyString = body.length > 0 ? `
${body}` : "";
    super(`${message}: Status ${statusCode} Content-Type ${contentType} Body ${bodyString}`);
    this.rawResponse = rawResponse;
    this.body = body;
    this.statusCode = statusCode;
    this.contentType = contentType;
    this.name = "APIError";
  }
};

// node_modules/creem/dist/esm/lib/http.js
var DEFAULT_FETCHER = (input, init) => {
  if (init == null) {
    return fetch(input);
  } else {
    return fetch(input, init);
  }
};
var HTTPClient = class _HTTPClient {
  constructor(options = {}) {
    this.options = options;
    this.requestHooks = [];
    this.requestErrorHooks = [];
    this.responseHooks = [];
    this.fetcher = options.fetcher || DEFAULT_FETCHER;
  }
  async request(request) {
    let req = request;
    for (const hook of this.requestHooks) {
      const nextRequest = await hook(req);
      if (nextRequest) {
        req = nextRequest;
      }
    }
    try {
      const res = await this.fetcher(req);
      for (const hook of this.responseHooks) {
        await hook(res, req);
      }
      return res;
    } catch (err) {
      for (const hook of this.requestErrorHooks) {
        await hook(err, req);
      }
      throw err;
    }
  }
  addHook(...args) {
    if (args[0] === "beforeRequest") {
      this.requestHooks.push(args[1]);
    } else if (args[0] === "requestError") {
      this.requestErrorHooks.push(args[1]);
    } else if (args[0] === "response") {
      this.responseHooks.push(args[1]);
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    return this;
  }
  removeHook(...args) {
    let target;
    if (args[0] === "beforeRequest") {
      target = this.requestHooks;
    } else if (args[0] === "requestError") {
      target = this.requestErrorHooks;
    } else if (args[0] === "response") {
      target = this.responseHooks;
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    const index = target.findIndex((v) => v === args[1]);
    if (index >= 0) {
      target.splice(index, 1);
    }
    return this;
  }
  clone() {
    const child = new _HTTPClient(this.options);
    child.requestHooks = this.requestHooks.slice();
    child.requestErrorHooks = this.requestErrorHooks.slice();
    child.responseHooks = this.responseHooks.slice();
    return child;
  }
};
var mediaParamSeparator = /\s*;\s*/g;
function matchContentType(response, pattern) {
  if (pattern === "*") {
    return true;
  }
  let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
  contentType = contentType.toLowerCase();
  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;
  if (wantType.split("/").length !== 2) {
    return false;
  }
  const gotParts = contentType.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;
  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }
  if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
    return false;
  }
  if (gotParams.length < wantParams.length) {
    return false;
  }
  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }
  return true;
}
var codeRangeRE = new RegExp("^[0-9]xx$", "i");
function matchStatusCode(response, codes) {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }
  return expectedCodes.some((ec) => {
    const code = `${ec}`;
    if (code === "default") {
      return true;
    }
    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
function matchResponse(response, code, contentTypePattern) {
  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
function isConnectionError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
  const isBunErr = "name" in err && err.name === "ConnectionError";
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
function isTimeoutError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
function isAbortError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}

// node_modules/creem/dist/esm/models/errors/sdkvalidationerror.js
var SDKValidationError = class extends Error {
  constructor(message, cause, rawValue) {
    super(`${message}: ${cause}`);
    this.name = "SDKValidationError";
    this.cause = cause;
    this.rawValue = rawValue;
    this.rawMessage = message;
  }
  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  pretty() {
    if (this.cause instanceof ZodError) {
      return `${this.rawMessage}
${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
};
function formatZodError(err, level = 0) {
  let pre = "  ".repeat(level);
  pre = level > 0 ? `│${pre}` : pre;
  pre += " ".repeat(level);
  let message = "";
  const append = (str) => message += `
${pre}${str}`;
  const len = err.issues.length;
  const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
  if (len) {
    append(`┌ ${headline}:`);
  }
  for (const issue2 of err.issues) {
    let path = issue2.path.join(".");
    path = path ? `<root>.${path}` : "<root>";
    append(`│ • [${path}]: ${issue2.message} (${issue2.code})`);
    switch (issue2.code) {
      case "invalid_literal":
      case "invalid_type": {
        append(`│     Want: ${issue2.expected}`);
        append(`│      Got: ${issue2.received}`);
        break;
      }
      case "unrecognized_keys": {
        append(`│     Keys: ${issue2.keys.join(", ")}`);
        break;
      }
      case "invalid_enum_value": {
        append(`│     Allowed: ${issue2.options.join(", ")}`);
        append(`│         Got: ${issue2.received}`);
        break;
      }
      case "invalid_union_discriminator": {
        append(`│     Allowed: ${issue2.options.join(", ")}`);
        break;
      }
      case "invalid_union": {
        const len2 = issue2.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len2} union members:`);
        issue2.unionErrors.forEach((err2, i) => {
          append(`│   ✖︎ Member ${i + 1} of ${len2}`);
          append(`${formatZodError(err2, level + 1)}`);
        });
      }
    }
  }
  if (err.issues.length) {
    append(`└─*`);
  }
  return message.slice(1);
}

// node_modules/creem/dist/esm/types/fp.js
function OK(value) {
  return { ok: true, value };
}
function ERR(error2) {
  return { ok: false, error: error2 };
}
async function unwrapAsync(pr) {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}

// node_modules/creem/dist/esm/lib/schemas.js
function safeParse3(rawValue, fn, errorMessage) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}

// node_modules/creem/dist/esm/lib/matchers.js
var DEFAULT_CONTENT_TYPES = {
  jsonl: "application/jsonl",
  json: "application/json",
  text: "text/plain",
  bytes: "application/octet-stream",
  stream: "application/octet-stream",
  sse: "text/event-stream",
  nil: "*",
  fail: "*"
};
function json(codes, schema, options) {
  return { ...options, enc: "json", codes, schema };
}
function fail(codes) {
  return { enc: "fail", codes };
}
function match(...matchers) {
  return async function matchFunc(response, options) {
    let raw;
    let matcher;
    for (const match2 of matchers) {
      const { codes } = match2;
      const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match2;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match2;
        break;
      }
    }
    if (!matcher) {
      const responseBody = await response.text();
      return [{
        ok: false,
        error: new APIError("Unexpected API response status or content-type", response, responseBody)
      }, responseBody];
    }
    const encoding = matcher.enc;
    switch (encoding) {
      case "json":
        raw = await response.json();
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        raw = await response.text();
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        raw = await discardResponseBody(response);
        break;
      case "fail":
        raw = await response.text();
        break;
      default:
        encoding;
        throw new Error(`Unsupported response type: ${encoding}`);
    }
    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new APIError("API error occurred", response, typeof raw === "string" ? raw : "")
      }, raw];
    }
    const resultKey = matcher.key || options?.resultKey;
    let data;
    if ("err" in matcher) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null
      };
    } else if (resultKey) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        [resultKey]: raw
      };
    } else if (matcher.hdrs) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject2(raw) ? raw : null
      };
    } else {
      data = raw;
    }
    if ("err" in matcher) {
      const result = safeParse3(data, (v) => matcher.schema.parse(v), "Response validation failed");
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParse3(data, (v) => matcher.schema.parse(v), "Response validation failed"),
        raw
      ];
    }
  };
}
var headerValRE = /, */;
function unpackHeaders(headers) {
  const out = {};
  for (const [k, v] of headers.entries()) {
    out[k] = v.split(headerValRE);
  }
  return out;
}
async function discardResponseBody(res) {
  const reader = res.body?.getReader();
  if (reader == null) {
    return;
  }
  try {
    let done = false;
    while (!done) {
      const res2 = await reader.read();
      done = res2.done;
    }
  } finally {
    reader.releaseLock();
  }
}

// node_modules/creem/dist/esm/lib/primitives.js
function remap(inp, mappings) {
  let out = {};
  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }
  for (const [k, v] of Object.entries(inp)) {
    const j = mappings[k];
    if (j === null) {
      continue;
    }
    out[j ?? k] = v;
  }
  return out;
}
function compactMap(values) {
  const out = {};
  for (const [k, v] of Object.entries(values)) {
    if (typeof v !== "undefined") {
      out[k] = v;
    }
  }
  return out;
}

// node_modules/creem/dist/esm/models/components/activatelicenserequestentity.js
var ActivateLicenseRequestEntity$inboundSchema = object({
  key: string2(),
  instance_name: string2()
}).transform((v) => {
  return remap(v, {
    "instance_name": "instanceName"
  });
});
var ActivateLicenseRequestEntity$outboundSchema = object({
  key: string2(),
  instanceName: string2()
}).transform((v) => {
  return remap(v, {
    instanceName: "instance_name"
  });
});
var ActivateLicenseRequestEntity$;
(function(ActivateLicenseRequestEntity$2) {
  ActivateLicenseRequestEntity$2.inboundSchema = ActivateLicenseRequestEntity$inboundSchema;
  ActivateLicenseRequestEntity$2.outboundSchema = ActivateLicenseRequestEntity$outboundSchema;
})(ActivateLicenseRequestEntity$ || (ActivateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerentity.js
var CustomerEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var CustomerEntityMode$inboundSchema = nativeEnum(CustomerEntityMode);
var CustomerEntityMode$outboundSchema = CustomerEntityMode$inboundSchema;
var CustomerEntityMode$;
(function(CustomerEntityMode$2) {
  CustomerEntityMode$2.inboundSchema = CustomerEntityMode$inboundSchema;
  CustomerEntityMode$2.outboundSchema = CustomerEntityMode$outboundSchema;
})(CustomerEntityMode$ || (CustomerEntityMode$ = {}));
var CustomerEntity$inboundSchema = object({
  id: string2(),
  mode: CustomerEntityMode$inboundSchema,
  object: string2(),
  email: string2(),
  name: string2().optional(),
  country: string2(),
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string2().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var CustomerEntity$outboundSchema = object({
  id: string2(),
  mode: CustomerEntityMode$outboundSchema,
  object: string2(),
  email: string2(),
  name: string2().optional(),
  country: string2(),
  createdAt: date3().transform((v) => v.toISOString()),
  updatedAt: date3().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var CustomerEntity$;
(function(CustomerEntity$2) {
  CustomerEntity$2.inboundSchema = CustomerEntity$inboundSchema;
  CustomerEntity$2.outboundSchema = CustomerEntity$outboundSchema;
})(CustomerEntity$ || (CustomerEntity$ = {}));

// node_modules/creem/dist/esm/models/components/text.js
var Text$inboundSchema = object({
  max_length: number2().optional(),
  min_length: number2().optional()
}).transform((v) => {
  return remap(v, {
    "max_length": "maxLength",
    "min_length": "minLength"
  });
});
var Text$outboundSchema = object({
  maxLength: number2().optional(),
  minLength: number2().optional()
}).transform((v) => {
  return remap(v, {
    maxLength: "max_length",
    minLength: "min_length"
  });
});
var Text$;
(function(Text$2) {
  Text$2.inboundSchema = Text$inboundSchema;
  Text$2.outboundSchema = Text$outboundSchema;
})(Text$ || (Text$ = {}));

// node_modules/creem/dist/esm/models/components/customfield.js
var CustomField$inboundSchema = object({
  type: string2(),
  key: string2(),
  label: string2(),
  optional: boolean2().optional(),
  text: Text$inboundSchema.optional()
});
var CustomField$outboundSchema = object({
  type: string2(),
  key: string2(),
  label: string2(),
  optional: boolean2().optional(),
  text: Text$outboundSchema.optional()
});
var CustomField$;
(function(CustomField$2) {
  CustomField$2.inboundSchema = CustomField$inboundSchema;
  CustomField$2.outboundSchema = CustomField$outboundSchema;
})(CustomField$ || (CustomField$ = {}));

// node_modules/creem/dist/esm/models/components/orderentity.js
var OrderEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var OrderEntityStatus = {
  Pending: "pending",
  Paid: "paid"
};
var OrderEntityType = {
  Recurring: "recurring",
  Onetime: "onetime"
};
var OrderEntityMode$inboundSchema = nativeEnum(OrderEntityMode);
var OrderEntityMode$outboundSchema = OrderEntityMode$inboundSchema;
var OrderEntityMode$;
(function(OrderEntityMode$2) {
  OrderEntityMode$2.inboundSchema = OrderEntityMode$inboundSchema;
  OrderEntityMode$2.outboundSchema = OrderEntityMode$outboundSchema;
})(OrderEntityMode$ || (OrderEntityMode$ = {}));
var OrderEntityStatus$inboundSchema = nativeEnum(OrderEntityStatus);
var OrderEntityStatus$outboundSchema = OrderEntityStatus$inboundSchema;
var OrderEntityStatus$;
(function(OrderEntityStatus$2) {
  OrderEntityStatus$2.inboundSchema = OrderEntityStatus$inboundSchema;
  OrderEntityStatus$2.outboundSchema = OrderEntityStatus$outboundSchema;
})(OrderEntityStatus$ || (OrderEntityStatus$ = {}));
var OrderEntityType$inboundSchema = nativeEnum(OrderEntityType);
var OrderEntityType$outboundSchema = OrderEntityType$inboundSchema;
var OrderEntityType$;
(function(OrderEntityType$2) {
  OrderEntityType$2.inboundSchema = OrderEntityType$inboundSchema;
  OrderEntityType$2.outboundSchema = OrderEntityType$outboundSchema;
})(OrderEntityType$ || (OrderEntityType$ = {}));
var OrderEntity$inboundSchema = object({
  id: string2(),
  mode: OrderEntityMode$inboundSchema,
  object: string2(),
  customer: string2().optional(),
  product: string2(),
  transaction: string2().optional(),
  discount: string2().optional(),
  amount: number2(),
  sub_total: number2().optional(),
  tax_amount: number2().optional(),
  discount_amount: number2().optional(),
  amount_due: number2().optional(),
  amount_paid: number2().optional(),
  currency: string2(),
  fx_amount: number2().optional(),
  fx_currency: string2().optional(),
  fx_rate: number2().optional(),
  status: OrderEntityStatus$inboundSchema,
  type: OrderEntityType$inboundSchema,
  affiliate: string2().optional(),
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string2().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "sub_total": "subTotal",
    "tax_amount": "taxAmount",
    "discount_amount": "discountAmount",
    "amount_due": "amountDue",
    "amount_paid": "amountPaid",
    "fx_amount": "fxAmount",
    "fx_currency": "fxCurrency",
    "fx_rate": "fxRate",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var OrderEntity$outboundSchema = object({
  id: string2(),
  mode: OrderEntityMode$outboundSchema,
  object: string2(),
  customer: string2().optional(),
  product: string2(),
  transaction: string2().optional(),
  discount: string2().optional(),
  amount: number2(),
  subTotal: number2().optional(),
  taxAmount: number2().optional(),
  discountAmount: number2().optional(),
  amountDue: number2().optional(),
  amountPaid: number2().optional(),
  currency: string2(),
  fxAmount: number2().optional(),
  fxCurrency: string2().optional(),
  fxRate: number2().optional(),
  status: OrderEntityStatus$outboundSchema,
  type: OrderEntityType$outboundSchema,
  affiliate: string2().optional(),
  createdAt: date3().transform((v) => v.toISOString()),
  updatedAt: date3().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    subTotal: "sub_total",
    taxAmount: "tax_amount",
    discountAmount: "discount_amount",
    amountDue: "amount_due",
    amountPaid: "amount_paid",
    fxAmount: "fx_amount",
    fxCurrency: "fx_currency",
    fxRate: "fx_rate",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var OrderEntity$;
(function(OrderEntity$2) {
  OrderEntity$2.inboundSchema = OrderEntity$inboundSchema;
  OrderEntity$2.outboundSchema = OrderEntity$outboundSchema;
})(OrderEntity$ || (OrderEntity$ = {}));

// node_modules/creem/dist/esm/models/components/featureentity.js
var FeatureEntity$inboundSchema = object({
  id: string2(),
  type: string2(),
  description: string2()
});
var FeatureEntity$outboundSchema = object({
  id: string2(),
  type: string2(),
  description: string2()
});
var FeatureEntity$;
(function(FeatureEntity$2) {
  FeatureEntity$2.inboundSchema = FeatureEntity$inboundSchema;
  FeatureEntity$2.outboundSchema = FeatureEntity$outboundSchema;
})(FeatureEntity$ || (FeatureEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productentity.js
var Mode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var Mode$inboundSchema = nativeEnum(Mode);
var Mode$outboundSchema = Mode$inboundSchema;
var Mode$;
(function(Mode$2) {
  Mode$2.inboundSchema = Mode$inboundSchema;
  Mode$2.outboundSchema = Mode$outboundSchema;
})(Mode$ || (Mode$ = {}));
var ProductEntity$inboundSchema = object({
  id: string2(),
  mode: Mode$inboundSchema,
  object: string2(),
  name: string2(),
  description: string2(),
  image_url: string2().optional(),
  features: array(FeatureEntity$inboundSchema).optional(),
  price: number2(),
  currency: string2(),
  billing_type: string2(),
  billing_period: string2(),
  status: string2(),
  tax_mode: string2(),
  tax_category: string2(),
  product_url: string2().optional(),
  default_success_url: nullable(string2()).optional(),
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string2().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "product_url": "productUrl",
    "default_success_url": "defaultSuccessUrl",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var ProductEntity$outboundSchema = object({
  id: string2(),
  mode: Mode$outboundSchema,
  object: string2(),
  name: string2(),
  description: string2(),
  imageUrl: string2().optional(),
  features: array(FeatureEntity$outboundSchema).optional(),
  price: number2(),
  currency: string2(),
  billingType: string2(),
  billingPeriod: string2(),
  status: string2(),
  taxMode: string2(),
  taxCategory: string2(),
  productUrl: string2().optional(),
  defaultSuccessUrl: nullable(string2()).optional(),
  createdAt: date3().transform((v) => v.toISOString()),
  updatedAt: date3().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    productUrl: "product_url",
    defaultSuccessUrl: "default_success_url",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var ProductEntity$;
(function(ProductEntity$2) {
  ProductEntity$2.inboundSchema = ProductEntity$inboundSchema;
  ProductEntity$2.outboundSchema = ProductEntity$outboundSchema;
})(ProductEntity$ || (ProductEntity$ = {}));

// node_modules/creem/dist/esm/models/components/licenseentity.js
var LicenseEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var LicenseEntityStatus = {
  Inactive: "inactive",
  Active: "active",
  Expired: "expired",
  Disabled: "disabled"
};
var LicenseEntityInstanceMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var LicenseEntityInstanceStatus = {
  Active: "active",
  Deactivated: "deactivated"
};
var LicenseEntityMode$inboundSchema = nativeEnum(LicenseEntityMode);
var LicenseEntityMode$outboundSchema = LicenseEntityMode$inboundSchema;
var LicenseEntityMode$;
(function(LicenseEntityMode$2) {
  LicenseEntityMode$2.inboundSchema = LicenseEntityMode$inboundSchema;
  LicenseEntityMode$2.outboundSchema = LicenseEntityMode$outboundSchema;
})(LicenseEntityMode$ || (LicenseEntityMode$ = {}));
var LicenseEntityStatus$inboundSchema = nativeEnum(LicenseEntityStatus);
var LicenseEntityStatus$outboundSchema = LicenseEntityStatus$inboundSchema;
var LicenseEntityStatus$;
(function(LicenseEntityStatus$2) {
  LicenseEntityStatus$2.inboundSchema = LicenseEntityStatus$inboundSchema;
  LicenseEntityStatus$2.outboundSchema = LicenseEntityStatus$outboundSchema;
})(LicenseEntityStatus$ || (LicenseEntityStatus$ = {}));
var ActivationLimit$inboundSchema = object({});
var ActivationLimit$outboundSchema = object({});
var ActivationLimit$;
(function(ActivationLimit$2) {
  ActivationLimit$2.inboundSchema = ActivationLimit$inboundSchema;
  ActivationLimit$2.outboundSchema = ActivationLimit$outboundSchema;
})(ActivationLimit$ || (ActivationLimit$ = {}));
var ExpiresAt$inboundSchema = object({});
var ExpiresAt$outboundSchema = object({});
var ExpiresAt$;
(function(ExpiresAt$2) {
  ExpiresAt$2.inboundSchema = ExpiresAt$inboundSchema;
  ExpiresAt$2.outboundSchema = ExpiresAt$outboundSchema;
})(ExpiresAt$ || (ExpiresAt$ = {}));
var LicenseEntityInstanceMode$inboundSchema = nativeEnum(LicenseEntityInstanceMode);
var LicenseEntityInstanceMode$outboundSchema = LicenseEntityInstanceMode$inboundSchema;
var LicenseEntityInstanceMode$;
(function(LicenseEntityInstanceMode$2) {
  LicenseEntityInstanceMode$2.inboundSchema = LicenseEntityInstanceMode$inboundSchema;
  LicenseEntityInstanceMode$2.outboundSchema = LicenseEntityInstanceMode$outboundSchema;
})(LicenseEntityInstanceMode$ || (LicenseEntityInstanceMode$ = {}));
var LicenseEntityInstanceStatus$inboundSchema = nativeEnum(LicenseEntityInstanceStatus);
var LicenseEntityInstanceStatus$outboundSchema = LicenseEntityInstanceStatus$inboundSchema;
var LicenseEntityInstanceStatus$;
(function(LicenseEntityInstanceStatus$2) {
  LicenseEntityInstanceStatus$2.inboundSchema = LicenseEntityInstanceStatus$inboundSchema;
  LicenseEntityInstanceStatus$2.outboundSchema = LicenseEntityInstanceStatus$outboundSchema;
})(LicenseEntityInstanceStatus$ || (LicenseEntityInstanceStatus$ = {}));
var Instance$inboundSchema = object({
  id: string2(),
  mode: LicenseEntityInstanceMode$inboundSchema,
  object: string2(),
  name: string2(),
  status: LicenseEntityInstanceStatus$inboundSchema,
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "created_at": "createdAt"
  });
});
var Instance$outboundSchema = object({
  id: string2(),
  mode: LicenseEntityInstanceMode$outboundSchema,
  object: string2(),
  name: string2(),
  status: LicenseEntityInstanceStatus$outboundSchema,
  createdAt: date3().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    createdAt: "created_at"
  });
});
var Instance$;
(function(Instance$2) {
  Instance$2.inboundSchema = Instance$inboundSchema;
  Instance$2.outboundSchema = Instance$outboundSchema;
})(Instance$ || (Instance$ = {}));
var LicenseEntity$inboundSchema = object({
  id: string2(),
  mode: LicenseEntityMode$inboundSchema,
  object: string2(),
  status: LicenseEntityStatus$inboundSchema,
  key: string2(),
  activation: number2(),
  activation_limit: nullable(lazy(() => ActivationLimit$inboundSchema)).optional(),
  expires_at: nullable(lazy(() => ExpiresAt$inboundSchema)).optional(),
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v)),
  instance: nullable(lazy(() => Instance$inboundSchema)).optional()
}).transform((v) => {
  return remap(v, {
    "activation_limit": "activationLimit",
    "expires_at": "expiresAt",
    "created_at": "createdAt"
  });
});
var LicenseEntity$outboundSchema = object({
  id: string2(),
  mode: LicenseEntityMode$outboundSchema,
  object: string2(),
  status: LicenseEntityStatus$outboundSchema,
  key: string2(),
  activation: number2(),
  activationLimit: nullable(lazy(() => ActivationLimit$outboundSchema)).optional(),
  expiresAt: nullable(lazy(() => ExpiresAt$outboundSchema)).optional(),
  createdAt: date3().transform((v) => v.toISOString()),
  instance: nullable(lazy(() => Instance$outboundSchema)).optional()
}).transform((v) => {
  return remap(v, {
    activationLimit: "activation_limit",
    expiresAt: "expires_at",
    createdAt: "created_at"
  });
});
var LicenseEntity$;
(function(LicenseEntity$2) {
  LicenseEntity$2.inboundSchema = LicenseEntity$inboundSchema;
  LicenseEntity$2.outboundSchema = LicenseEntity$outboundSchema;
})(LicenseEntity$ || (LicenseEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productfeatureentity.js
var ProductFeatureEntity$inboundSchema = object({
  license: LicenseEntity$inboundSchema
});
var ProductFeatureEntity$outboundSchema = object({
  license: LicenseEntity$outboundSchema
});
var ProductFeatureEntity$;
(function(ProductFeatureEntity$2) {
  ProductFeatureEntity$2.inboundSchema = ProductFeatureEntity$inboundSchema;
  ProductFeatureEntity$2.outboundSchema = ProductFeatureEntity$outboundSchema;
})(ProductFeatureEntity$ || (ProductFeatureEntity$ = {}));

// node_modules/creem/dist/esm/models/components/subscriptionitementity.js
var SubscriptionItemEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var SubscriptionItemEntityMode$inboundSchema = nativeEnum(SubscriptionItemEntityMode);
var SubscriptionItemEntityMode$outboundSchema = SubscriptionItemEntityMode$inboundSchema;
var SubscriptionItemEntityMode$;
(function(SubscriptionItemEntityMode$2) {
  SubscriptionItemEntityMode$2.inboundSchema = SubscriptionItemEntityMode$inboundSchema;
  SubscriptionItemEntityMode$2.outboundSchema = SubscriptionItemEntityMode$outboundSchema;
})(SubscriptionItemEntityMode$ || (SubscriptionItemEntityMode$ = {}));
var SubscriptionItemEntity$inboundSchema = object({
  id: string2(),
  mode: SubscriptionItemEntityMode$inboundSchema,
  object: string2(),
  product_id: string2().optional(),
  price_id: string2().optional(),
  units: number2().optional()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "price_id": "priceId"
  });
});
var SubscriptionItemEntity$outboundSchema = object({
  id: string2(),
  mode: SubscriptionItemEntityMode$outboundSchema,
  object: string2(),
  productId: string2().optional(),
  priceId: string2().optional(),
  units: number2().optional()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    priceId: "price_id"
  });
});
var SubscriptionItemEntity$;
(function(SubscriptionItemEntity$2) {
  SubscriptionItemEntity$2.inboundSchema = SubscriptionItemEntity$inboundSchema;
  SubscriptionItemEntity$2.outboundSchema = SubscriptionItemEntity$outboundSchema;
})(SubscriptionItemEntity$ || (SubscriptionItemEntity$ = {}));

// node_modules/creem/dist/esm/models/components/transactionentity.js
var TransactionEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var TransactionEntityMode$inboundSchema = nativeEnum(TransactionEntityMode);
var TransactionEntityMode$outboundSchema = TransactionEntityMode$inboundSchema;
var TransactionEntityMode$;
(function(TransactionEntityMode$2) {
  TransactionEntityMode$2.inboundSchema = TransactionEntityMode$inboundSchema;
  TransactionEntityMode$2.outboundSchema = TransactionEntityMode$outboundSchema;
})(TransactionEntityMode$ || (TransactionEntityMode$ = {}));
var TransactionEntity$inboundSchema = object({
  id: string2(),
  mode: TransactionEntityMode$inboundSchema,
  object: string2(),
  amount: number2(),
  amount_paid: number2().optional(),
  discount_amount: number2().optional(),
  currency: string2(),
  type: string2(),
  tax_country: string2().optional(),
  tax_amount: number2().optional(),
  status: string2(),
  refunded_amount: nullable(number2()).optional(),
  order: nullable(string2()).optional(),
  subscription: nullable(string2()).optional(),
  customer: nullable(string2()).optional(),
  description: string2().optional(),
  period_start: number2().optional(),
  period_end: number2().optional(),
  created_at: number2()
}).transform((v) => {
  return remap(v, {
    "amount_paid": "amountPaid",
    "discount_amount": "discountAmount",
    "tax_country": "taxCountry",
    "tax_amount": "taxAmount",
    "refunded_amount": "refundedAmount",
    "period_start": "periodStart",
    "period_end": "periodEnd",
    "created_at": "createdAt"
  });
});
var TransactionEntity$outboundSchema = object({
  id: string2(),
  mode: TransactionEntityMode$outboundSchema,
  object: string2(),
  amount: number2(),
  amountPaid: number2().optional(),
  discountAmount: number2().optional(),
  currency: string2(),
  type: string2(),
  taxCountry: string2().optional(),
  taxAmount: number2().optional(),
  status: string2(),
  refundedAmount: nullable(number2()).optional(),
  order: nullable(string2()).optional(),
  subscription: nullable(string2()).optional(),
  customer: nullable(string2()).optional(),
  description: string2().optional(),
  periodStart: number2().optional(),
  periodEnd: number2().optional(),
  createdAt: number2()
}).transform((v) => {
  return remap(v, {
    amountPaid: "amount_paid",
    discountAmount: "discount_amount",
    taxCountry: "tax_country",
    taxAmount: "tax_amount",
    refundedAmount: "refunded_amount",
    periodStart: "period_start",
    periodEnd: "period_end",
    createdAt: "created_at"
  });
});
var TransactionEntity$;
(function(TransactionEntity$2) {
  TransactionEntity$2.inboundSchema = TransactionEntity$inboundSchema;
  TransactionEntity$2.outboundSchema = TransactionEntity$outboundSchema;
})(TransactionEntity$ || (TransactionEntity$ = {}));

// node_modules/creem/dist/esm/models/components/subscriptionentity.js
var SubscriptionEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var Status = {
  Active: "active",
  Canceled: "canceled",
  Unpaid: "unpaid",
  Paused: "paused",
  Trialing: "trialing"
};
var SubscriptionEntityMode$inboundSchema = nativeEnum(SubscriptionEntityMode);
var SubscriptionEntityMode$outboundSchema = SubscriptionEntityMode$inboundSchema;
var SubscriptionEntityMode$;
(function(SubscriptionEntityMode$2) {
  SubscriptionEntityMode$2.inboundSchema = SubscriptionEntityMode$inboundSchema;
  SubscriptionEntityMode$2.outboundSchema = SubscriptionEntityMode$outboundSchema;
})(SubscriptionEntityMode$ || (SubscriptionEntityMode$ = {}));
var Product$inboundSchema = union([ProductEntity$inboundSchema, string2()]);
var Product$outboundSchema = union([ProductEntity$outboundSchema, string2()]);
var Product$;
(function(Product$2) {
  Product$2.inboundSchema = Product$inboundSchema;
  Product$2.outboundSchema = Product$outboundSchema;
})(Product$ || (Product$ = {}));
var Customer$inboundSchema = union([CustomerEntity$inboundSchema, string2()]);
var Customer$outboundSchema = union([CustomerEntity$outboundSchema, string2()]);
var Customer$;
(function(Customer$2) {
  Customer$2.inboundSchema = Customer$inboundSchema;
  Customer$2.outboundSchema = Customer$outboundSchema;
})(Customer$ || (Customer$ = {}));
var Status$inboundSchema = nativeEnum(Status);
var Status$outboundSchema = Status$inboundSchema;
var Status$;
(function(Status$2) {
  Status$2.inboundSchema = Status$inboundSchema;
  Status$2.outboundSchema = Status$outboundSchema;
})(Status$ || (Status$ = {}));
var SubscriptionEntity$inboundSchema = object({
  id: string2(),
  mode: SubscriptionEntityMode$inboundSchema,
  object: string2(),
  product: union([ProductEntity$inboundSchema, string2()]),
  customer: union([CustomerEntity$inboundSchema, string2()]),
  items: array(SubscriptionItemEntity$inboundSchema).optional(),
  collection_method: string2(),
  status: Status$inboundSchema,
  last_transaction_id: string2().optional(),
  last_transaction: TransactionEntity$inboundSchema.optional(),
  last_transaction_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  next_transaction_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  current_period_start_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  current_period_end_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  canceled_at: nullable(string2().datetime({ offset: true }).transform((v) => new Date(v))).optional(),
  created_at: string2().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string2().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "collection_method": "collectionMethod",
    "last_transaction_id": "lastTransactionId",
    "last_transaction": "lastTransaction",
    "last_transaction_date": "lastTransactionDate",
    "next_transaction_date": "nextTransactionDate",
    "current_period_start_date": "currentPeriodStartDate",
    "current_period_end_date": "currentPeriodEndDate",
    "canceled_at": "canceledAt",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var SubscriptionEntity$outboundSchema = object({
  id: string2(),
  mode: SubscriptionEntityMode$outboundSchema,
  object: string2(),
  product: union([ProductEntity$outboundSchema, string2()]),
  customer: union([CustomerEntity$outboundSchema, string2()]),
  items: array(SubscriptionItemEntity$outboundSchema).optional(),
  collectionMethod: string2(),
  status: Status$outboundSchema,
  lastTransactionId: string2().optional(),
  lastTransaction: TransactionEntity$outboundSchema.optional(),
  lastTransactionDate: date3().transform((v) => v.toISOString()).optional(),
  nextTransactionDate: date3().transform((v) => v.toISOString()).optional(),
  currentPeriodStartDate: date3().transform((v) => v.toISOString()).optional(),
  currentPeriodEndDate: date3().transform((v) => v.toISOString()).optional(),
  canceledAt: nullable(date3().transform((v) => v.toISOString())).optional(),
  createdAt: date3().transform((v) => v.toISOString()),
  updatedAt: date3().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    collectionMethod: "collection_method",
    lastTransactionId: "last_transaction_id",
    lastTransaction: "last_transaction",
    lastTransactionDate: "last_transaction_date",
    nextTransactionDate: "next_transaction_date",
    currentPeriodStartDate: "current_period_start_date",
    currentPeriodEndDate: "current_period_end_date",
    canceledAt: "canceled_at",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var SubscriptionEntity$;
(function(SubscriptionEntity$2) {
  SubscriptionEntity$2.inboundSchema = SubscriptionEntity$inboundSchema;
  SubscriptionEntity$2.outboundSchema = SubscriptionEntity$outboundSchema;
})(SubscriptionEntity$ || (SubscriptionEntity$ = {}));

// node_modules/creem/dist/esm/models/components/checkoutentity.js
var CheckoutEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var CheckoutEntityMode$inboundSchema = nativeEnum(CheckoutEntityMode);
var CheckoutEntityMode$outboundSchema = CheckoutEntityMode$inboundSchema;
var CheckoutEntityMode$;
(function(CheckoutEntityMode$2) {
  CheckoutEntityMode$2.inboundSchema = CheckoutEntityMode$inboundSchema;
  CheckoutEntityMode$2.outboundSchema = CheckoutEntityMode$outboundSchema;
})(CheckoutEntityMode$ || (CheckoutEntityMode$ = {}));
var CheckoutEntityProduct$inboundSchema = union([ProductEntity$inboundSchema, string2()]);
var CheckoutEntityProduct$outboundSchema = union([ProductEntity$outboundSchema, string2()]);
var CheckoutEntityProduct$;
(function(CheckoutEntityProduct$2) {
  CheckoutEntityProduct$2.inboundSchema = CheckoutEntityProduct$inboundSchema;
  CheckoutEntityProduct$2.outboundSchema = CheckoutEntityProduct$outboundSchema;
})(CheckoutEntityProduct$ || (CheckoutEntityProduct$ = {}));
var Subscription$inboundSchema = union([SubscriptionEntity$inboundSchema, string2()]);
var Subscription$outboundSchema = union([SubscriptionEntity$outboundSchema, string2()]);
var Subscription$;
(function(Subscription$2) {
  Subscription$2.inboundSchema = Subscription$inboundSchema;
  Subscription$2.outboundSchema = Subscription$outboundSchema;
})(Subscription$ || (Subscription$ = {}));
var CheckoutEntityCustomer$inboundSchema = union([CustomerEntity$inboundSchema, string2()]);
var CheckoutEntityCustomer$outboundSchema = union([CustomerEntity$outboundSchema, string2()]);
var CheckoutEntityCustomer$;
(function(CheckoutEntityCustomer$2) {
  CheckoutEntityCustomer$2.inboundSchema = CheckoutEntityCustomer$inboundSchema;
  CheckoutEntityCustomer$2.outboundSchema = CheckoutEntityCustomer$outboundSchema;
})(CheckoutEntityCustomer$ || (CheckoutEntityCustomer$ = {}));
var CheckoutEntity$inboundSchema = object({
  id: string2(),
  mode: CheckoutEntityMode$inboundSchema,
  object: string2(),
  status: string2(),
  request_id: string2().optional(),
  product: union([ProductEntity$inboundSchema, string2()]),
  units: number2().default(1),
  order: OrderEntity$inboundSchema.optional(),
  subscription: union([SubscriptionEntity$inboundSchema, string2()]).optional(),
  customer: union([CustomerEntity$inboundSchema, string2()]).optional(),
  custom_fields: array(CustomField$inboundSchema).optional(),
  checkout_url: string2().optional(),
  success_url: nullable(string2()).optional(),
  feature: array(ProductFeatureEntity$inboundSchema).optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    "request_id": "requestId",
    "custom_fields": "customFields",
    "checkout_url": "checkoutUrl",
    "success_url": "successUrl"
  });
});
var CheckoutEntity$outboundSchema = object({
  id: string2(),
  mode: CheckoutEntityMode$outboundSchema,
  object: string2(),
  status: string2(),
  requestId: string2().optional(),
  product: union([ProductEntity$outboundSchema, string2()]),
  units: number2().default(1),
  order: OrderEntity$outboundSchema.optional(),
  subscription: union([SubscriptionEntity$outboundSchema, string2()]).optional(),
  customer: union([CustomerEntity$outboundSchema, string2()]).optional(),
  customFields: array(CustomField$outboundSchema).optional(),
  checkoutUrl: string2().optional(),
  successUrl: nullable(string2()).optional(),
  feature: array(ProductFeatureEntity$outboundSchema).optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    requestId: "request_id",
    customFields: "custom_fields",
    checkoutUrl: "checkout_url",
    successUrl: "success_url"
  });
});
var CheckoutEntity$;
(function(CheckoutEntity$2) {
  CheckoutEntity$2.inboundSchema = CheckoutEntity$inboundSchema;
  CheckoutEntity$2.outboundSchema = CheckoutEntity$outboundSchema;
})(CheckoutEntity$ || (CheckoutEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerrequestentity.js
var CustomerRequestEntity$inboundSchema = object({
  id: string2().optional(),
  email: string2().optional()
});
var CustomerRequestEntity$outboundSchema = object({
  id: string2().optional(),
  email: string2().optional()
});
var CustomerRequestEntity$;
(function(CustomerRequestEntity$2) {
  CustomerRequestEntity$2.inboundSchema = CustomerRequestEntity$inboundSchema;
  CustomerRequestEntity$2.outboundSchema = CustomerRequestEntity$outboundSchema;
})(CustomerRequestEntity$ || (CustomerRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customfieldrequestentity.js
var Type = {
  Text: "text"
};
var Type$inboundSchema = nativeEnum(Type);
var Type$outboundSchema = Type$inboundSchema;
var Type$;
(function(Type$2) {
  Type$2.inboundSchema = Type$inboundSchema;
  Type$2.outboundSchema = Type$outboundSchema;
})(Type$ || (Type$ = {}));
var CustomFieldRequestEntity$inboundSchema = object({
  type: Type$inboundSchema,
  key: string2(),
  label: string2(),
  optional: boolean2().optional(),
  text: Text$inboundSchema.optional()
});
var CustomFieldRequestEntity$outboundSchema = object({
  type: Type$outboundSchema,
  key: string2(),
  label: string2(),
  optional: boolean2().optional(),
  text: Text$outboundSchema.optional()
});
var CustomFieldRequestEntity$;
(function(CustomFieldRequestEntity$2) {
  CustomFieldRequestEntity$2.inboundSchema = CustomFieldRequestEntity$inboundSchema;
  CustomFieldRequestEntity$2.outboundSchema = CustomFieldRequestEntity$outboundSchema;
})(CustomFieldRequestEntity$ || (CustomFieldRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/createcheckoutrequest.js
var CreateCheckoutRequest$inboundSchema = object({
  request_id: string2().optional(),
  product_id: string2(),
  units: number2().optional(),
  discount_code: string2().optional(),
  customer: CustomerRequestEntity$inboundSchema.optional(),
  custom_field: array(CustomFieldRequestEntity$inboundSchema).optional(),
  success_url: string2().optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    "request_id": "requestId",
    "product_id": "productId",
    "discount_code": "discountCode",
    "custom_field": "customField",
    "success_url": "successUrl"
  });
});
var CreateCheckoutRequest$outboundSchema = object({
  requestId: string2().optional(),
  productId: string2(),
  units: number2().optional(),
  discountCode: string2().optional(),
  customer: CustomerRequestEntity$outboundSchema.optional(),
  customField: array(CustomFieldRequestEntity$outboundSchema).optional(),
  successUrl: string2().optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    requestId: "request_id",
    productId: "product_id",
    discountCode: "discount_code",
    customField: "custom_field",
    successUrl: "success_url"
  });
});
var CreateCheckoutRequest$;
(function(CreateCheckoutRequest$3) {
  CreateCheckoutRequest$3.inboundSchema = CreateCheckoutRequest$inboundSchema;
  CreateCheckoutRequest$3.outboundSchema = CreateCheckoutRequest$outboundSchema;
})(CreateCheckoutRequest$ || (CreateCheckoutRequest$ = {}));

// node_modules/creem/dist/esm/models/components/createcustomerportallinkrequestentity.js
var CreateCustomerPortalLinkRequestEntity$inboundSchema = object({
  customer_id: string2()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId"
  });
});
var CreateCustomerPortalLinkRequestEntity$outboundSchema = object({
  customerId: string2()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id"
  });
});
var CreateCustomerPortalLinkRequestEntity$;
(function(CreateCustomerPortalLinkRequestEntity$2) {
  CreateCustomerPortalLinkRequestEntity$2.inboundSchema = CreateCustomerPortalLinkRequestEntity$inboundSchema;
  CreateCustomerPortalLinkRequestEntity$2.outboundSchema = CreateCustomerPortalLinkRequestEntity$outboundSchema;
})(CreateCustomerPortalLinkRequestEntity$ || (CreateCustomerPortalLinkRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/creatediscountrequestentity.js
var CreateDiscountRequestEntityType = {
  Percentage: "percentage",
  Fixed: "fixed"
};
var CreateDiscountRequestEntityDuration = {
  Forever: "forever",
  Once: "once",
  Repeating: "repeating"
};
var CreateDiscountRequestEntityType$inboundSchema = nativeEnum(CreateDiscountRequestEntityType);
var CreateDiscountRequestEntityType$outboundSchema = CreateDiscountRequestEntityType$inboundSchema;
var CreateDiscountRequestEntityType$;
(function(CreateDiscountRequestEntityType$2) {
  CreateDiscountRequestEntityType$2.inboundSchema = CreateDiscountRequestEntityType$inboundSchema;
  CreateDiscountRequestEntityType$2.outboundSchema = CreateDiscountRequestEntityType$outboundSchema;
})(CreateDiscountRequestEntityType$ || (CreateDiscountRequestEntityType$ = {}));
var CreateDiscountRequestEntityDuration$inboundSchema = nativeEnum(CreateDiscountRequestEntityDuration);
var CreateDiscountRequestEntityDuration$outboundSchema = CreateDiscountRequestEntityDuration$inboundSchema;
var CreateDiscountRequestEntityDuration$;
(function(CreateDiscountRequestEntityDuration$2) {
  CreateDiscountRequestEntityDuration$2.inboundSchema = CreateDiscountRequestEntityDuration$inboundSchema;
  CreateDiscountRequestEntityDuration$2.outboundSchema = CreateDiscountRequestEntityDuration$outboundSchema;
})(CreateDiscountRequestEntityDuration$ || (CreateDiscountRequestEntityDuration$ = {}));
var CreateDiscountRequestEntity$inboundSchema = object({
  name: string2(),
  code: string2().optional(),
  type: CreateDiscountRequestEntityType$inboundSchema,
  amount: number2().optional(),
  currency: string2().optional(),
  percentage: number2().optional(),
  expiry_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  max_redemptions: number2().optional(),
  duration: CreateDiscountRequestEntityDuration$inboundSchema,
  duration_in_months: number2().optional(),
  applies_to_products: array(string2())
}).transform((v) => {
  return remap(v, {
    "expiry_date": "expiryDate",
    "max_redemptions": "maxRedemptions",
    "duration_in_months": "durationInMonths",
    "applies_to_products": "appliesToProducts"
  });
});
var CreateDiscountRequestEntity$outboundSchema = object({
  name: string2(),
  code: string2().optional(),
  type: CreateDiscountRequestEntityType$outboundSchema,
  amount: number2().optional(),
  currency: string2().optional(),
  percentage: number2().optional(),
  expiryDate: date3().transform((v) => v.toISOString()).optional(),
  maxRedemptions: number2().optional(),
  duration: CreateDiscountRequestEntityDuration$outboundSchema,
  durationInMonths: number2().optional(),
  appliesToProducts: array(string2())
}).transform((v) => {
  return remap(v, {
    expiryDate: "expiry_date",
    maxRedemptions: "max_redemptions",
    durationInMonths: "duration_in_months",
    appliesToProducts: "applies_to_products"
  });
});
var CreateDiscountRequestEntity$;
(function(CreateDiscountRequestEntity$2) {
  CreateDiscountRequestEntity$2.inboundSchema = CreateDiscountRequestEntity$inboundSchema;
  CreateDiscountRequestEntity$2.outboundSchema = CreateDiscountRequestEntity$outboundSchema;
})(CreateDiscountRequestEntity$ || (CreateDiscountRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/createproductrequestentity.js
var CreateProductRequestEntity$inboundSchema = object({
  name: string2(),
  description: string2().optional(),
  image_url: string2().optional(),
  price: number2().int(),
  currency: string2(),
  billing_type: string2(),
  billing_period: string2().optional(),
  tax_mode: string2().optional(),
  tax_category: string2().optional(),
  default_success_url: string2().optional(),
  custom_field: array(CustomFieldRequestEntity$inboundSchema).optional()
}).transform((v) => {
  return remap(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "default_success_url": "defaultSuccessUrl",
    "custom_field": "customField"
  });
});
var CreateProductRequestEntity$outboundSchema = object({
  name: string2(),
  description: string2().optional(),
  imageUrl: string2().optional(),
  price: number2().int(),
  currency: string2(),
  billingType: string2(),
  billingPeriod: string2().optional(),
  taxMode: string2().optional(),
  taxCategory: string2().optional(),
  defaultSuccessUrl: string2().optional(),
  customField: array(CustomFieldRequestEntity$outboundSchema).optional()
}).transform((v) => {
  return remap(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    defaultSuccessUrl: "default_success_url",
    customField: "custom_field"
  });
});
var CreateProductRequestEntity$;
(function(CreateProductRequestEntity$2) {
  CreateProductRequestEntity$2.inboundSchema = CreateProductRequestEntity$inboundSchema;
  CreateProductRequestEntity$2.outboundSchema = CreateProductRequestEntity$outboundSchema;
})(CreateProductRequestEntity$ || (CreateProductRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerlinksentity.js
var CustomerLinksEntity$inboundSchema = object({
  customer_portal_link: string2()
}).transform((v) => {
  return remap(v, {
    "customer_portal_link": "customerPortalLink"
  });
});
var CustomerLinksEntity$outboundSchema = object({
  customerPortalLink: string2()
}).transform((v) => {
  return remap(v, {
    customerPortalLink: "customer_portal_link"
  });
});
var CustomerLinksEntity$;
(function(CustomerLinksEntity$2) {
  CustomerLinksEntity$2.inboundSchema = CustomerLinksEntity$inboundSchema;
  CustomerLinksEntity$2.outboundSchema = CustomerLinksEntity$outboundSchema;
})(CustomerLinksEntity$ || (CustomerLinksEntity$ = {}));

// node_modules/creem/dist/esm/models/components/deactivatelicenserequestentity.js
var DeactivateLicenseRequestEntity$inboundSchema = object({
  key: string2(),
  instance_id: string2()
}).transform((v) => {
  return remap(v, {
    "instance_id": "instanceId"
  });
});
var DeactivateLicenseRequestEntity$outboundSchema = object({
  key: string2(),
  instanceId: string2()
}).transform((v) => {
  return remap(v, {
    instanceId: "instance_id"
  });
});
var DeactivateLicenseRequestEntity$;
(function(DeactivateLicenseRequestEntity$2) {
  DeactivateLicenseRequestEntity$2.inboundSchema = DeactivateLicenseRequestEntity$inboundSchema;
  DeactivateLicenseRequestEntity$2.outboundSchema = DeactivateLicenseRequestEntity$outboundSchema;
})(DeactivateLicenseRequestEntity$ || (DeactivateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/discountentity.js
var DiscountEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var DiscountEntityStatus = {
  Active: "active",
  Draft: "draft",
  Expired: "expired",
  Scheduled: "scheduled"
};
var DiscountEntityType = {
  Percentage: "percentage",
  Fixed: "fixed"
};
var Duration = {
  Forever: "forever",
  Once: "once",
  Repeating: "repeating"
};
var DiscountEntityMode$inboundSchema = nativeEnum(DiscountEntityMode);
var DiscountEntityMode$outboundSchema = DiscountEntityMode$inboundSchema;
var DiscountEntityMode$;
(function(DiscountEntityMode$2) {
  DiscountEntityMode$2.inboundSchema = DiscountEntityMode$inboundSchema;
  DiscountEntityMode$2.outboundSchema = DiscountEntityMode$outboundSchema;
})(DiscountEntityMode$ || (DiscountEntityMode$ = {}));
var DiscountEntityStatus$inboundSchema = nativeEnum(DiscountEntityStatus);
var DiscountEntityStatus$outboundSchema = DiscountEntityStatus$inboundSchema;
var DiscountEntityStatus$;
(function(DiscountEntityStatus$2) {
  DiscountEntityStatus$2.inboundSchema = DiscountEntityStatus$inboundSchema;
  DiscountEntityStatus$2.outboundSchema = DiscountEntityStatus$outboundSchema;
})(DiscountEntityStatus$ || (DiscountEntityStatus$ = {}));
var DiscountEntityType$inboundSchema = nativeEnum(DiscountEntityType);
var DiscountEntityType$outboundSchema = DiscountEntityType$inboundSchema;
var DiscountEntityType$;
(function(DiscountEntityType$2) {
  DiscountEntityType$2.inboundSchema = DiscountEntityType$inboundSchema;
  DiscountEntityType$2.outboundSchema = DiscountEntityType$outboundSchema;
})(DiscountEntityType$ || (DiscountEntityType$ = {}));
var Duration$inboundSchema = nativeEnum(Duration);
var Duration$outboundSchema = Duration$inboundSchema;
var Duration$;
(function(Duration$2) {
  Duration$2.inboundSchema = Duration$inboundSchema;
  Duration$2.outboundSchema = Duration$outboundSchema;
})(Duration$ || (Duration$ = {}));
var DiscountEntity$inboundSchema = object({
  id: string2(),
  mode: DiscountEntityMode$inboundSchema,
  object: string2(),
  status: DiscountEntityStatus$inboundSchema,
  name: string2(),
  code: string2(),
  type: DiscountEntityType$inboundSchema,
  amount: number2().optional(),
  currency: string2().optional(),
  percentage: number2().optional(),
  expiry_date: string2().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  max_redemptions: number2().optional(),
  duration: Duration$inboundSchema.optional(),
  duration_in_months: number2().optional(),
  applies_to_products: array(string2()).optional()
}).transform((v) => {
  return remap(v, {
    "expiry_date": "expiryDate",
    "max_redemptions": "maxRedemptions",
    "duration_in_months": "durationInMonths",
    "applies_to_products": "appliesToProducts"
  });
});
var DiscountEntity$outboundSchema = object({
  id: string2(),
  mode: DiscountEntityMode$outboundSchema,
  object: string2(),
  status: DiscountEntityStatus$outboundSchema,
  name: string2(),
  code: string2(),
  type: DiscountEntityType$outboundSchema,
  amount: number2().optional(),
  currency: string2().optional(),
  percentage: number2().optional(),
  expiryDate: date3().transform((v) => v.toISOString()).optional(),
  maxRedemptions: number2().optional(),
  duration: Duration$outboundSchema.optional(),
  durationInMonths: number2().optional(),
  appliesToProducts: array(string2()).optional()
}).transform((v) => {
  return remap(v, {
    expiryDate: "expiry_date",
    maxRedemptions: "max_redemptions",
    durationInMonths: "duration_in_months",
    appliesToProducts: "applies_to_products"
  });
});
var DiscountEntity$;
(function(DiscountEntity$2) {
  DiscountEntity$2.inboundSchema = DiscountEntity$inboundSchema;
  DiscountEntity$2.outboundSchema = DiscountEntity$outboundSchema;
})(DiscountEntity$ || (DiscountEntity$ = {}));

// node_modules/creem/dist/esm/models/components/paginationentity.js
var PaginationEntity$inboundSchema = object({
  total_records: number2(),
  total_pages: number2(),
  current_page: number2(),
  next_page: nullable(number2()),
  prev_page: nullable(number2())
}).transform((v) => {
  return remap(v, {
    "total_records": "totalRecords",
    "total_pages": "totalPages",
    "current_page": "currentPage",
    "next_page": "nextPage",
    "prev_page": "prevPage"
  });
});
var PaginationEntity$outboundSchema = object({
  totalRecords: number2(),
  totalPages: number2(),
  currentPage: number2(),
  nextPage: nullable(number2()),
  prevPage: nullable(number2())
}).transform((v) => {
  return remap(v, {
    totalRecords: "total_records",
    totalPages: "total_pages",
    currentPage: "current_page",
    nextPage: "next_page",
    prevPage: "prev_page"
  });
});
var PaginationEntity$;
(function(PaginationEntity$2) {
  PaginationEntity$2.inboundSchema = PaginationEntity$inboundSchema;
  PaginationEntity$2.outboundSchema = PaginationEntity$outboundSchema;
})(PaginationEntity$ || (PaginationEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productlistentity.js
var ProductListEntity$inboundSchema = object({
  items: array(ProductEntity$inboundSchema),
  pagination: PaginationEntity$inboundSchema
});
var ProductListEntity$outboundSchema = object({
  items: array(ProductEntity$outboundSchema),
  pagination: PaginationEntity$outboundSchema
});
var ProductListEntity$;
(function(ProductListEntity$2) {
  ProductListEntity$2.inboundSchema = ProductListEntity$inboundSchema;
  ProductListEntity$2.outboundSchema = ProductListEntity$outboundSchema;
})(ProductListEntity$ || (ProductListEntity$ = {}));

// node_modules/creem/dist/esm/models/components/transactionlistentity.js
var TransactionListEntity$inboundSchema = object({
  items: array(TransactionEntity$inboundSchema),
  pagination: PaginationEntity$inboundSchema
});
var TransactionListEntity$outboundSchema = object({
  items: array(TransactionEntity$outboundSchema),
  pagination: PaginationEntity$outboundSchema
});
var TransactionListEntity$;
(function(TransactionListEntity$2) {
  TransactionListEntity$2.inboundSchema = TransactionListEntity$inboundSchema;
  TransactionListEntity$2.outboundSchema = TransactionListEntity$outboundSchema;
})(TransactionListEntity$ || (TransactionListEntity$ = {}));

// node_modules/creem/dist/esm/models/components/upsertsubscriptionitementity.js
var UpsertSubscriptionItemEntity$inboundSchema = object({
  id: string2().optional(),
  product_id: string2().optional(),
  price_id: string2().optional(),
  units: number2().optional()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "price_id": "priceId"
  });
});
var UpsertSubscriptionItemEntity$outboundSchema = object({
  id: string2().optional(),
  productId: string2().optional(),
  priceId: string2().optional(),
  units: number2().optional()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    priceId: "price_id"
  });
});
var UpsertSubscriptionItemEntity$;
(function(UpsertSubscriptionItemEntity$2) {
  UpsertSubscriptionItemEntity$2.inboundSchema = UpsertSubscriptionItemEntity$inboundSchema;
  UpsertSubscriptionItemEntity$2.outboundSchema = UpsertSubscriptionItemEntity$outboundSchema;
})(UpsertSubscriptionItemEntity$ || (UpsertSubscriptionItemEntity$ = {}));

// node_modules/creem/dist/esm/models/components/updatesubscriptionrequestentity.js
var UpdateBehavior = {
  ProrationChargeImmediately: "proration-charge-immediately",
  ProrationCharge: "proration-charge",
  ProrationNone: "proration-none"
};
var UpdateBehavior$inboundSchema = nativeEnum(UpdateBehavior);
var UpdateBehavior$outboundSchema = UpdateBehavior$inboundSchema;
var UpdateBehavior$;
(function(UpdateBehavior$2) {
  UpdateBehavior$2.inboundSchema = UpdateBehavior$inboundSchema;
  UpdateBehavior$2.outboundSchema = UpdateBehavior$outboundSchema;
})(UpdateBehavior$ || (UpdateBehavior$ = {}));
var UpdateSubscriptionRequestEntity$inboundSchema = object({
  items: array(UpsertSubscriptionItemEntity$inboundSchema).optional(),
  update_behavior: UpdateBehavior$inboundSchema.default("proration-charge")
}).transform((v) => {
  return remap(v, {
    "update_behavior": "updateBehavior"
  });
});
var UpdateSubscriptionRequestEntity$outboundSchema = object({
  items: array(UpsertSubscriptionItemEntity$outboundSchema).optional(),
  updateBehavior: UpdateBehavior$outboundSchema.default("proration-charge")
}).transform((v) => {
  return remap(v, {
    updateBehavior: "update_behavior"
  });
});
var UpdateSubscriptionRequestEntity$;
(function(UpdateSubscriptionRequestEntity$2) {
  UpdateSubscriptionRequestEntity$2.inboundSchema = UpdateSubscriptionRequestEntity$inboundSchema;
  UpdateSubscriptionRequestEntity$2.outboundSchema = UpdateSubscriptionRequestEntity$outboundSchema;
})(UpdateSubscriptionRequestEntity$ || (UpdateSubscriptionRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/upgradesubscriptionrequestentity.js
var UpgradeSubscriptionRequestEntityUpdateBehavior = {
  ProrationChargeImmediately: "proration-charge-immediately",
  ProrationCharge: "proration-charge",
  ProrationNone: "proration-none"
};
var UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema = nativeEnum(UpgradeSubscriptionRequestEntityUpdateBehavior);
var UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema;
var UpgradeSubscriptionRequestEntityUpdateBehavior$;
(function(UpgradeSubscriptionRequestEntityUpdateBehavior$2) {
  UpgradeSubscriptionRequestEntityUpdateBehavior$2.inboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema;
  UpgradeSubscriptionRequestEntityUpdateBehavior$2.outboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema;
})(UpgradeSubscriptionRequestEntityUpdateBehavior$ || (UpgradeSubscriptionRequestEntityUpdateBehavior$ = {}));
var UpgradeSubscriptionRequestEntity$inboundSchema = object({
  product_id: string2(),
  update_behavior: UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema.default("proration-charge-immediately")
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "update_behavior": "updateBehavior"
  });
});
var UpgradeSubscriptionRequestEntity$outboundSchema = object({
  productId: string2(),
  updateBehavior: UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema.default("proration-charge-immediately")
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    updateBehavior: "update_behavior"
  });
});
var UpgradeSubscriptionRequestEntity$;
(function(UpgradeSubscriptionRequestEntity$2) {
  UpgradeSubscriptionRequestEntity$2.inboundSchema = UpgradeSubscriptionRequestEntity$inboundSchema;
  UpgradeSubscriptionRequestEntity$2.outboundSchema = UpgradeSubscriptionRequestEntity$outboundSchema;
})(UpgradeSubscriptionRequestEntity$ || (UpgradeSubscriptionRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/validatelicenserequestentity.js
var ValidateLicenseRequestEntity$inboundSchema = object({
  key: string2(),
  instance_id: string2()
}).transform((v) => {
  return remap(v, {
    "instance_id": "instanceId"
  });
});
var ValidateLicenseRequestEntity$outboundSchema = object({
  key: string2(),
  instanceId: string2()
}).transform((v) => {
  return remap(v, {
    instanceId: "instance_id"
  });
});
var ValidateLicenseRequestEntity$;
(function(ValidateLicenseRequestEntity$2) {
  ValidateLicenseRequestEntity$2.inboundSchema = ValidateLicenseRequestEntity$inboundSchema;
  ValidateLicenseRequestEntity$2.outboundSchema = ValidateLicenseRequestEntity$outboundSchema;
})(ValidateLicenseRequestEntity$ || (ValidateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/operations/activatelicense.js
var ActivateLicenseRequest$inboundSchema = object({
  "x-api-key": string2(),
  ActivateLicenseRequestEntity: ActivateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "ActivateLicenseRequestEntity": "activateLicenseRequestEntity"
  });
});
var ActivateLicenseRequest$outboundSchema = object({
  xApiKey: string2(),
  activateLicenseRequestEntity: ActivateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    activateLicenseRequestEntity: "ActivateLicenseRequestEntity"
  });
});
var ActivateLicenseRequest$;
(function(ActivateLicenseRequest$2) {
  ActivateLicenseRequest$2.inboundSchema = ActivateLicenseRequest$inboundSchema;
  ActivateLicenseRequest$2.outboundSchema = ActivateLicenseRequest$outboundSchema;
})(ActivateLicenseRequest$ || (ActivateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/cancelsubscription.js
var CancelSubscriptionRequest$inboundSchema = object({
  id: string2(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey"
  });
});
var CancelSubscriptionRequest$outboundSchema = object({
  id: string2(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key"
  });
});
var CancelSubscriptionRequest$;
(function(CancelSubscriptionRequest$2) {
  CancelSubscriptionRequest$2.inboundSchema = CancelSubscriptionRequest$inboundSchema;
  CancelSubscriptionRequest$2.outboundSchema = CancelSubscriptionRequest$outboundSchema;
})(CancelSubscriptionRequest$ || (CancelSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/createcheckout.js
var CreateCheckoutRequest$inboundSchema2 = object({
  "x-api-key": string2(),
  CreateCheckoutRequest: CreateCheckoutRequest$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateCheckoutRequest": "createCheckoutRequest"
  });
});
var CreateCheckoutRequest$outboundSchema2 = object({
  xApiKey: string2(),
  createCheckoutRequest: CreateCheckoutRequest$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createCheckoutRequest: "CreateCheckoutRequest"
  });
});
var CreateCheckoutRequest$2;
(function(CreateCheckoutRequest$3) {
  CreateCheckoutRequest$3.inboundSchema = CreateCheckoutRequest$inboundSchema2;
  CreateCheckoutRequest$3.outboundSchema = CreateCheckoutRequest$outboundSchema2;
})(CreateCheckoutRequest$2 || (CreateCheckoutRequest$2 = {}));

// node_modules/creem/dist/esm/models/operations/creatediscount.js
var CreateDiscountRequest$inboundSchema = object({
  "x-api-key": string2(),
  CreateDiscountRequestEntity: CreateDiscountRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateDiscountRequestEntity": "createDiscountRequestEntity"
  });
});
var CreateDiscountRequest$outboundSchema = object({
  xApiKey: string2(),
  createDiscountRequestEntity: CreateDiscountRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createDiscountRequestEntity: "CreateDiscountRequestEntity"
  });
});
var CreateDiscountRequest$;
(function(CreateDiscountRequest$2) {
  CreateDiscountRequest$2.inboundSchema = CreateDiscountRequest$inboundSchema;
  CreateDiscountRequest$2.outboundSchema = CreateDiscountRequest$outboundSchema;
})(CreateDiscountRequest$ || (CreateDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/createproduct.js
var CreateProductRequest$inboundSchema = object({
  "x-api-key": string2(),
  CreateProductRequestEntity: CreateProductRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateProductRequestEntity": "createProductRequestEntity"
  });
});
var CreateProductRequest$outboundSchema = object({
  xApiKey: string2(),
  createProductRequestEntity: CreateProductRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createProductRequestEntity: "CreateProductRequestEntity"
  });
});
var CreateProductRequest$;
(function(CreateProductRequest$2) {
  CreateProductRequest$2.inboundSchema = CreateProductRequest$inboundSchema;
  CreateProductRequest$2.outboundSchema = CreateProductRequest$outboundSchema;
})(CreateProductRequest$ || (CreateProductRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/deactivatelicense.js
var DeactivateLicenseRequest$inboundSchema = object({
  "x-api-key": string2(),
  DeactivateLicenseRequestEntity: DeactivateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "DeactivateLicenseRequestEntity": "deactivateLicenseRequestEntity"
  });
});
var DeactivateLicenseRequest$outboundSchema = object({
  xApiKey: string2(),
  deactivateLicenseRequestEntity: DeactivateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    deactivateLicenseRequestEntity: "DeactivateLicenseRequestEntity"
  });
});
var DeactivateLicenseRequest$;
(function(DeactivateLicenseRequest$2) {
  DeactivateLicenseRequest$2.inboundSchema = DeactivateLicenseRequest$inboundSchema;
  DeactivateLicenseRequest$2.outboundSchema = DeactivateLicenseRequest$outboundSchema;
})(DeactivateLicenseRequest$ || (DeactivateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/deletediscount.js
var DeleteDiscountRequest$inboundSchema = object({
  id: string2(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey"
  });
});
var DeleteDiscountRequest$outboundSchema = object({
  id: string2(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key"
  });
});
var DeleteDiscountRequest$;
(function(DeleteDiscountRequest$2) {
  DeleteDiscountRequest$2.inboundSchema = DeleteDiscountRequest$inboundSchema;
  DeleteDiscountRequest$2.outboundSchema = DeleteDiscountRequest$outboundSchema;
})(DeleteDiscountRequest$ || (DeleteDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/generatecustomerlinks.js
var GenerateCustomerLinksRequest$inboundSchema = object({
  "x-api-key": string2(),
  CreateCustomerPortalLinkRequestEntity: CreateCustomerPortalLinkRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateCustomerPortalLinkRequestEntity": "createCustomerPortalLinkRequestEntity"
  });
});
var GenerateCustomerLinksRequest$outboundSchema = object({
  xApiKey: string2(),
  createCustomerPortalLinkRequestEntity: CreateCustomerPortalLinkRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createCustomerPortalLinkRequestEntity: "CreateCustomerPortalLinkRequestEntity"
  });
});
var GenerateCustomerLinksRequest$;
(function(GenerateCustomerLinksRequest$2) {
  GenerateCustomerLinksRequest$2.inboundSchema = GenerateCustomerLinksRequest$inboundSchema;
  GenerateCustomerLinksRequest$2.outboundSchema = GenerateCustomerLinksRequest$outboundSchema;
})(GenerateCustomerLinksRequest$ || (GenerateCustomerLinksRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievecheckout.js
var RetrieveCheckoutRequest$inboundSchema = object({
  checkout_id: string2(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "checkout_id": "checkoutId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveCheckoutRequest$outboundSchema = object({
  checkoutId: string2(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    checkoutId: "checkout_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveCheckoutRequest$;
(function(RetrieveCheckoutRequest$2) {
  RetrieveCheckoutRequest$2.inboundSchema = RetrieveCheckoutRequest$inboundSchema;
  RetrieveCheckoutRequest$2.outboundSchema = RetrieveCheckoutRequest$outboundSchema;
})(RetrieveCheckoutRequest$ || (RetrieveCheckoutRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievecustomer.js
var RetrieveCustomerRequest$inboundSchema = object({
  customer_id: string2().optional(),
  email: string2().optional(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveCustomerRequest$outboundSchema = object({
  customerId: string2().optional(),
  email: string2().optional(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveCustomerRequest$;
(function(RetrieveCustomerRequest$2) {
  RetrieveCustomerRequest$2.inboundSchema = RetrieveCustomerRequest$inboundSchema;
  RetrieveCustomerRequest$2.outboundSchema = RetrieveCustomerRequest$outboundSchema;
})(RetrieveCustomerRequest$ || (RetrieveCustomerRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievediscount.js
var RetrieveDiscountRequest$inboundSchema = object({
  discount_id: string2().optional(),
  discount_code: string2().optional(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "discount_id": "discountId",
    "discount_code": "discountCode",
    "x-api-key": "xApiKey"
  });
});
var RetrieveDiscountRequest$outboundSchema = object({
  discountId: string2().optional(),
  discountCode: string2().optional(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    discountId: "discount_id",
    discountCode: "discount_code",
    xApiKey: "x-api-key"
  });
});
var RetrieveDiscountRequest$;
(function(RetrieveDiscountRequest$2) {
  RetrieveDiscountRequest$2.inboundSchema = RetrieveDiscountRequest$inboundSchema;
  RetrieveDiscountRequest$2.outboundSchema = RetrieveDiscountRequest$outboundSchema;
})(RetrieveDiscountRequest$ || (RetrieveDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrieveproduct.js
var RetrieveProductRequest$inboundSchema = object({
  product_id: string2(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveProductRequest$outboundSchema = object({
  productId: string2(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveProductRequest$;
(function(RetrieveProductRequest$2) {
  RetrieveProductRequest$2.inboundSchema = RetrieveProductRequest$inboundSchema;
  RetrieveProductRequest$2.outboundSchema = RetrieveProductRequest$outboundSchema;
})(RetrieveProductRequest$ || (RetrieveProductRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievesubscription.js
var RetrieveSubscriptionRequest$inboundSchema = object({
  subscription_id: string2(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "subscription_id": "subscriptionId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveSubscriptionRequest$outboundSchema = object({
  subscriptionId: string2(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    subscriptionId: "subscription_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveSubscriptionRequest$;
(function(RetrieveSubscriptionRequest$2) {
  RetrieveSubscriptionRequest$2.inboundSchema = RetrieveSubscriptionRequest$inboundSchema;
  RetrieveSubscriptionRequest$2.outboundSchema = RetrieveSubscriptionRequest$outboundSchema;
})(RetrieveSubscriptionRequest$ || (RetrieveSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/searchproducts.js
var SearchProductsRequest$inboundSchema = object({
  page_number: number2().optional(),
  page_size: number2().optional(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "page_number": "pageNumber",
    "page_size": "pageSize",
    "x-api-key": "xApiKey"
  });
});
var SearchProductsRequest$outboundSchema = object({
  pageNumber: number2().optional(),
  pageSize: number2().optional(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    pageNumber: "page_number",
    pageSize: "page_size",
    xApiKey: "x-api-key"
  });
});
var SearchProductsRequest$;
(function(SearchProductsRequest$2) {
  SearchProductsRequest$2.inboundSchema = SearchProductsRequest$inboundSchema;
  SearchProductsRequest$2.outboundSchema = SearchProductsRequest$outboundSchema;
})(SearchProductsRequest$ || (SearchProductsRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/searchtransactions.js
var SearchTransactionsRequest$inboundSchema = object({
  customer_id: string2().optional(),
  order_id: string2().optional(),
  product_id: string2().optional(),
  page_number: number2().optional(),
  page_size: number2().optional(),
  "x-api-key": string2()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId",
    "order_id": "orderId",
    "product_id": "productId",
    "page_number": "pageNumber",
    "page_size": "pageSize",
    "x-api-key": "xApiKey"
  });
});
var SearchTransactionsRequest$outboundSchema = object({
  customerId: string2().optional(),
  orderId: string2().optional(),
  productId: string2().optional(),
  pageNumber: number2().optional(),
  pageSize: number2().optional(),
  xApiKey: string2()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id",
    orderId: "order_id",
    productId: "product_id",
    pageNumber: "page_number",
    pageSize: "page_size",
    xApiKey: "x-api-key"
  });
});
var SearchTransactionsRequest$;
(function(SearchTransactionsRequest$2) {
  SearchTransactionsRequest$2.inboundSchema = SearchTransactionsRequest$inboundSchema;
  SearchTransactionsRequest$2.outboundSchema = SearchTransactionsRequest$outboundSchema;
})(SearchTransactionsRequest$ || (SearchTransactionsRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/updatesubscription.js
var UpdateSubscriptionRequest$inboundSchema = object({
  id: string2(),
  "x-api-key": string2(),
  UpdateSubscriptionRequestEntity: UpdateSubscriptionRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "UpdateSubscriptionRequestEntity": "updateSubscriptionRequestEntity"
  });
});
var UpdateSubscriptionRequest$outboundSchema = object({
  id: string2(),
  xApiKey: string2(),
  updateSubscriptionRequestEntity: UpdateSubscriptionRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    updateSubscriptionRequestEntity: "UpdateSubscriptionRequestEntity"
  });
});
var UpdateSubscriptionRequest$;
(function(UpdateSubscriptionRequest$2) {
  UpdateSubscriptionRequest$2.inboundSchema = UpdateSubscriptionRequest$inboundSchema;
  UpdateSubscriptionRequest$2.outboundSchema = UpdateSubscriptionRequest$outboundSchema;
})(UpdateSubscriptionRequest$ || (UpdateSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/upgradesubscription.js
var UpgradeSubscriptionRequest$inboundSchema = object({
  id: string2(),
  "x-api-key": string2(),
  UpgradeSubscriptionRequestEntity: UpgradeSubscriptionRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "UpgradeSubscriptionRequestEntity": "upgradeSubscriptionRequestEntity"
  });
});
var UpgradeSubscriptionRequest$outboundSchema = object({
  id: string2(),
  xApiKey: string2(),
  upgradeSubscriptionRequestEntity: UpgradeSubscriptionRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    upgradeSubscriptionRequestEntity: "UpgradeSubscriptionRequestEntity"
  });
});
var UpgradeSubscriptionRequest$;
(function(UpgradeSubscriptionRequest$2) {
  UpgradeSubscriptionRequest$2.inboundSchema = UpgradeSubscriptionRequest$inboundSchema;
  UpgradeSubscriptionRequest$2.outboundSchema = UpgradeSubscriptionRequest$outboundSchema;
})(UpgradeSubscriptionRequest$ || (UpgradeSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/validatelicense.js
var ValidateLicenseRequest$inboundSchema = object({
  "x-api-key": string2(),
  ValidateLicenseRequestEntity: ValidateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "ValidateLicenseRequestEntity": "validateLicenseRequestEntity"
  });
});
var ValidateLicenseRequest$outboundSchema = object({
  xApiKey: string2(),
  validateLicenseRequestEntity: ValidateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    validateLicenseRequestEntity: "ValidateLicenseRequestEntity"
  });
});
var ValidateLicenseRequest$;
(function(ValidateLicenseRequest$2) {
  ValidateLicenseRequest$2.inboundSchema = ValidateLicenseRequest$inboundSchema;
  ValidateLicenseRequest$2.outboundSchema = ValidateLicenseRequest$outboundSchema;
})(ValidateLicenseRequest$ || (ValidateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/types/async.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _APIPromise_promise;
var _APIPromise_unwrapped;
var _a;
var APIPromise = class {
  constructor(p) {
    _APIPromise_promise.set(this, void 0);
    _APIPromise_unwrapped.set(this, void 0);
    this[_a] = "APIPromise";
    __classPrivateFieldSet(this, _APIPromise_promise, p instanceof Promise ? p : Promise.resolve(p), "f");
    __classPrivateFieldSet(this, _APIPromise_unwrapped, p instanceof Promise ? __classPrivateFieldGet(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p[0]), "f");
  }
  then(onfulfilled, onrejected) {
    return __classPrivateFieldGet(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
  }
  catch(onrejected) {
    return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").catch(onrejected);
  }
  finally(onfinally) {
    return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").finally(onfinally);
  }
  $inspect() {
    return __classPrivateFieldGet(this, _APIPromise_promise, "f");
  }
};
_APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a = Symbol.toStringTag;

// node_modules/creem/dist/esm/funcs/activateLicense.js
function activateLicense(client, request, options) {
  return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
  const parsed = safeParse3(request, (value) => ActivateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ActivateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/activate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "activateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/cancelSubscription.js
function cancelSubscription(client, request, options) {
  return new APIPromise($do2(client, request, options));
}
async function $do2(client, request, options) {
  const parsed = safeParse3(request, (value) => CancelSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}/cancel")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "cancelSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createCheckout.js
function createCheckout(client, request, options) {
  return new APIPromise($do3(client, request, options));
}
async function $do3(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateCheckoutRequest$outboundSchema2.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateCheckoutRequest, {
    explode: true
  });
  const path = pathToFunc("/v1/checkouts")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createCheckout",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CheckoutEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createDiscount.js
function createDiscount(client, request, options) {
  return new APIPromise($do4(client, request, options));
}
async function $do4(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateDiscountRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/discounts")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createProduct.js
function createProduct(client, request, options) {
  return new APIPromise($do5(client, request, options));
}
async function $do5(client, request, options) {
  const parsed = safeParse3(request, (value) => CreateProductRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateProductRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/products")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createProduct",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/deactivateLicense.js
function deactivateLicense(client, request, options) {
  return new APIPromise($do6(client, request, options));
}
async function $do6(client, request, options) {
  const parsed = safeParse3(request, (value) => DeactivateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DeactivateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/deactivate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deactivateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/deleteDiscount.js
function deleteDiscount(client, request, options) {
  return new APIPromise($do7(client, request, options));
}
async function $do7(client, request, options) {
  const parsed = safeParse3(request, (value) => DeleteDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/discounts/{id}/delete")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/generateCustomerLinks.js
function generateCustomerLinks(client, request, options) {
  return new APIPromise($do8(client, request, options));
}
async function $do8(client, request, options) {
  const parsed = safeParse3(request, (value) => GenerateCustomerLinksRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateCustomerPortalLinkRequestEntity, { explode: true });
  const path = pathToFunc("/v1/customers/billing")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "generateCustomerLinks",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerLinksEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveCheckout.js
function retrieveCheckout(client, request, options) {
  return new APIPromise($do9(client, request, options));
}
async function $do9(client, request, options) {
  const parsed = safeParse3(request, (value) => RetrieveCheckoutRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/checkouts")();
  const query = encodeFormQuery({
    "checkout_id": payload.checkout_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "retrieveCheckout",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CheckoutEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveCustomer.js
function retrieveCustomer(client, request, options) {
  return new APIPromise($do10(client, request, options));
}
async function $do10(client, request, options) {
  const parsed = safeParse3(request, (value) => RetrieveCustomerRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customers")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "email": payload.email
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "retrieveCustomer",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveDiscount.js
function retrieveDiscount(client, request, options) {
  return new APIPromise($do11(client, request, options));
}
async function $do11(client, request, options) {
  const parsed = safeParse3(request, (value) => RetrieveDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/discounts")();
  const query = encodeFormQuery({
    "discount_code": payload.discount_code,
    "discount_id": payload.discount_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "retrieveDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveProduct.js
function retrieveProduct(client, request, options) {
  return new APIPromise($do12(client, request, options));
}
async function $do12(client, request, options) {
  const parsed = safeParse3(request, (value) => RetrieveProductRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/products")();
  const query = encodeFormQuery({
    "product_id": payload.product_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "retrieveProduct",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveSubscription.js
function retrieveSubscription(client, request, options) {
  return new APIPromise($do13(client, request, options));
}
async function $do13(client, request, options) {
  const parsed = safeParse3(request, (value) => RetrieveSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/subscriptions")();
  const query = encodeFormQuery({
    "subscription_id": payload.subscription_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "retrieveSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/searchProducts.js
function searchProducts(client, request, options) {
  return new APIPromise($do14(client, request, options));
}
async function $do14(client, request, options) {
  const parsed = safeParse3(request, (value) => SearchProductsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/products/search")();
  const query = encodeFormQuery({
    "page_number": payload.page_number,
    "page_size": payload.page_size
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "searchProducts",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductListEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/searchTransactions.js
function searchTransactions(client, request, options) {
  return new APIPromise($do15(client, request, options));
}
async function $do15(client, request, options) {
  const parsed = safeParse3(request, (value) => SearchTransactionsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/transactions/search")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "order_id": payload.order_id,
    "page_number": payload.page_number,
    "page_size": payload.page_size,
    "product_id": payload.product_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "searchTransactions",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, TransactionListEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/updateSubscription.js
function updateSubscription(client, request, options) {
  return new APIPromise($do16(client, request, options));
}
async function $do16(client, request, options) {
  const parsed = safeParse3(request, (value) => UpdateSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateSubscriptionRequestEntity, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/upgradeSubscription.js
function upgradeSubscription(client, request, options) {
  return new APIPromise($do17(client, request, options));
}
async function $do17(client, request, options) {
  const parsed = safeParse3(request, (value) => UpgradeSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpgradeSubscriptionRequestEntity, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}/upgrade")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "upgradeSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/validateLicense.js
function validateLicense(client, request, options) {
  return new APIPromise($do18(client, request, options));
}
async function $do18(client, request, options) {
  const parsed = safeParse3(request, (value) => ValidateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ValidateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/validate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "validateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/hooks/hooks.js
var SDKHooks = class {
  constructor() {
    this.sdkInitHooks = [];
    this.beforeCreateRequestHooks = [];
    this.beforeRequestHooks = [];
    this.afterSuccessHooks = [];
    this.afterErrorHooks = [];
    const presetHooks = [];
    for (const hook of presetHooks) {
      if ("sdkInit" in hook) {
        this.registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        this.registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        this.registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        this.registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        this.registerAfterErrorHook(hook);
      }
    }
  }
  registerSDKInitHook(hook) {
    this.sdkInitHooks.push(hook);
  }
  registerBeforeCreateRequestHook(hook) {
    this.beforeCreateRequestHooks.push(hook);
  }
  registerBeforeRequestHook(hook) {
    this.beforeRequestHooks.push(hook);
  }
  registerAfterSuccessHook(hook) {
    this.afterSuccessHooks.push(hook);
  }
  registerAfterErrorHook(hook) {
    this.afterErrorHooks.push(hook);
  }
  sdkInit(opts) {
    return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
  }
  beforeCreateRequest(hookCtx, input) {
    let inp = input;
    for (const hook of this.beforeCreateRequestHooks) {
      inp = hook.beforeCreateRequest(hookCtx, inp);
    }
    return inp;
  }
  async beforeRequest(hookCtx, request) {
    let req = request;
    for (const hook of this.beforeRequestHooks) {
      req = await hook.beforeRequest(hookCtx, req);
    }
    return req;
  }
  async afterSuccess(hookCtx, response) {
    let res = response;
    for (const hook of this.afterSuccessHooks) {
      res = await hook.afterSuccess(hookCtx, res);
    }
    return res;
  }
  async afterError(hookCtx, response, error2) {
    let res = response;
    let err = error2;
    for (const hook of this.afterErrorHooks) {
      const result = await hook.afterError(hookCtx, res, err);
      res = result.response;
      err = result.error;
    }
    return { response: res, error: err };
  }
};

// node_modules/creem/dist/esm/models/errors/httpclienterrors.js
var HTTPClientError = class extends Error {
  constructor(message, opts) {
    let msg = message;
    if (opts?.cause) {
      msg += `: ${opts.cause}`;
    }
    super(msg, opts);
    this.name = "HTTPClientError";
    if (typeof this.cause === "undefined") {
      this.cause = opts?.cause;
    }
  }
};
var UnexpectedClientError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "UnexpectedClientError";
  }
};
var InvalidRequestError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "InvalidRequestError";
  }
};
var RequestAbortedError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestAbortedError";
  }
};
var RequestTimeoutError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestTimeoutError";
  }
};
var ConnectionError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "ConnectionError";
  }
};

// node_modules/creem/dist/esm/lib/dlv.js
function dlv(obj, key, def, p, undef) {
  key = Array.isArray(key) ? key : key.split(".");
  for (p = 0; p < key.length; p++) {
    const k = key[p];
    obj = k != null && obj ? obj[k] : undef;
  }
  return obj === undef ? def : obj;
}

// node_modules/creem/dist/esm/lib/env.js
var envSchema = object({
  CREEM_DEBUG: coerce_exports.boolean().optional()
});
var envMemo = void 0;
function env() {
  if (envMemo) {
    return envMemo;
  }
  envMemo = envSchema.parse(dlv(globalThis, "process.env") ?? dlv(globalThis, "Deno.env") ?? {});
  return envMemo;
}

// node_modules/creem/dist/esm/lib/retries.js
var defaultBackoff = {
  initialInterval: 500,
  maxInterval: 6e4,
  exponent: 1.5,
  maxElapsedTime: 36e5
};
var PermanentError = class _PermanentError extends Error {
  constructor(message, options) {
    let msg = message;
    if (options?.cause) {
      msg += `: ${options.cause}`;
    }
    super(msg, options);
    this.name = "PermanentError";
    if (typeof this.cause === "undefined") {
      this.cause = options?.cause;
    }
    Object.setPrototypeOf(this, _PermanentError.prototype);
  }
};
var TemporaryError = class _TemporaryError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "TemporaryError";
    Object.setPrototypeOf(this, _TemporaryError.prototype);
  }
};
async function retry(fetchFn, options) {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(wrapFetcher(fetchFn, {
        statusCodes: options.statusCodes,
        retryConnectionErrors: !!options.config.retryConnectionErrors
      }), options.config.backoff ?? defaultBackoff);
    default:
      return await fetchFn();
  }
}
function wrapFetcher(fn, options) {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError("Response failed with retryable status code", res);
      }
      return res;
    } catch (err) {
      if (err instanceof TemporaryError) {
        throw err;
      }
      if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
        throw err;
      }
      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}
var codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
function isRetryableResponse(res, statusCodes) {
  const actual = `${res.status}`;
  return statusCodes.some((code) => {
    if (!codeRangeRE2.test(code)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
async function retryBackoff(fn, strategy) {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
  const start = Date.now();
  let x = 0;
  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }
        throw err;
      }
      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }
      if (retryInterval <= 0) {
        retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1e3;
      }
      const d = Math.min(retryInterval, maxInterval);
      await delay(d);
      x++;
    }
  }
}
function retryIntervalFromResponse(res) {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }
  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1e3;
  }
  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }
  return 0;
}
async function delay(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}

// node_modules/creem/dist/esm/lib/sdks.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClientSDK_httpClient;
var _ClientSDK_hooks;
var _ClientSDK_logger;
var gt = typeof globalThis === "undefined" ? null : globalThis;
var webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
var isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
var ClientSDK = class {
  constructor(options = {}) {
    _ClientSDK_httpClient.set(this, void 0);
    _ClientSDK_hooks.set(this, void 0);
    _ClientSDK_logger.set(this, void 0);
    const opt = options;
    if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof SDKHooks) {
      __classPrivateFieldSet2(this, _ClientSDK_hooks, opt.hooks, "f");
    } else {
      __classPrivateFieldSet2(this, _ClientSDK_hooks, new SDKHooks(), "f");
    }
    this._options = { ...options, hooks: __classPrivateFieldGet2(this, _ClientSDK_hooks, "f") };
    const url = serverURLFromOptions(options);
    if (url) {
      url.pathname = url.pathname.replace(/\/+$/, "") + "/";
    }
    const { baseURL, client } = __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").sdkInit({
      baseURL: url,
      client: options.httpClient || new HTTPClient()
    });
    this._baseURL = baseURL;
    __classPrivateFieldSet2(this, _ClientSDK_httpClient, client, "f");
    __classPrivateFieldSet2(this, _ClientSDK_logger, options.debugLogger, "f");
    if (!__classPrivateFieldGet2(this, _ClientSDK_logger, "f") && env().CREEM_DEBUG) {
      __classPrivateFieldSet2(this, _ClientSDK_logger, console, "f");
    }
  }
  _createRequest(context, conf, options) {
    const { method, path, query, headers: opHeaders, security } = conf;
    const base = conf.baseURL ?? this._baseURL;
    if (!base) {
      return ERR(new InvalidRequestError("No base URL provided for operation"));
    }
    const reqURL = new URL(base);
    const inputURL = new URL(path, reqURL);
    if (path) {
      reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
      reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
    }
    let finalQuery = query || "";
    const secQuery = [];
    for (const [k, v] of Object.entries(security?.queryParams || {})) {
      const q = encodeForm(k, v, { charEncoding: "percent" });
      if (typeof q !== "undefined") {
        secQuery.push(q);
      }
    }
    if (secQuery.length) {
      finalQuery += `&${secQuery.join("&")}`;
    }
    if (finalQuery) {
      const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
      reqURL.search = `?${q}`;
    }
    const headers = new Headers(opHeaders);
    const username = security?.basic.username;
    const password = security?.basic.password;
    if (username != null || password != null) {
      const encoded = stringToBase64([username || "", password || ""].join(":"));
      headers.set("Authorization", `Basic ${encoded}`);
    }
    const securityHeaders = new Headers(security?.headers || {});
    for (const [k, v] of securityHeaders) {
      headers.set(k, v);
    }
    let cookie = headers.get("cookie") || "";
    for (const [k, v] of Object.entries(security?.cookies || {})) {
      cookie += `; ${k}=${v}`;
    }
    cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
    headers.set("cookie", cookie);
    const userHeaders = new Headers(options?.headers ?? options?.fetchOptions?.headers);
    for (const [k, v] of userHeaders) {
      headers.set(k, v);
    }
    if (!isBrowserLike) {
      headers.set(conf.uaHeader ?? "user-agent", SDK_METADATA.userAgent);
    }
    const fetchOptions = {
      ...options?.fetchOptions,
      ...options
    };
    if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
      const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
      fetchOptions.signal = timeoutSignal;
    }
    if (conf.body instanceof ReadableStream) {
      Object.assign(fetchOptions, { duplex: "half" });
    }
    let input;
    try {
      input = __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
        url: reqURL,
        options: {
          ...fetchOptions,
          body: conf.body ?? null,
          headers,
          method
        }
      });
    } catch (err) {
      return ERR(new UnexpectedClientError("Create request hook failed to execute", {
        cause: err
      }));
    }
    return OK(new Request(input.url, input.options));
  }
  async _do(request, options) {
    const { context, errorCodes } = options;
    return retry(async () => {
      const req = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
      await logRequest(__classPrivateFieldGet2(this, _ClientSDK_logger, "f"), req).catch((e) => __classPrivateFieldGet2(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e));
      let response = await __classPrivateFieldGet2(this, _ClientSDK_httpClient, "f").request(req);
      try {
        if (matchStatusCode(response, errorCodes)) {
          const result = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").afterError(context, response, null);
          if (result.error) {
            throw result.error;
          }
          response = result.response || response;
        } else {
          response = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
        }
      } finally {
        await logResponse(__classPrivateFieldGet2(this, _ClientSDK_logger, "f"), response, req).catch((e) => __classPrivateFieldGet2(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e));
      }
      return response;
    }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK(r), (err) => {
      switch (true) {
        case isAbortError(err):
          return ERR(new RequestAbortedError("Request aborted by client", {
            cause: err
          }));
        case isTimeoutError(err):
          return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
        case isConnectionError(err):
          return ERR(new ConnectionError("Unable to make request", { cause: err }));
        default:
          return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
            cause: err
          }));
      }
    });
  }
};
_ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap();
var jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
var jsonlLikeContentTypeRE = /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
async function logRequest(logger, req) {
  if (!logger) {
    return;
  }
  const contentType = req.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";
  logger.group(`> Request: ${req.method} ${req.url}`);
  logger.group("Headers:");
  for (const [k, v] of req.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct):
      logger.log(await req.clone().json());
      break;
    case ct.startsWith("text/"):
      logger.log(await req.clone().text());
      break;
    case ct === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}
async function logResponse(logger, res, req) {
  if (!logger) {
    return;
  }
  const contentType = res.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";
  logger.group(`< Response: ${req.method} ${req.url}`);
  logger.log("Status Code:", res.status, res.statusText);
  logger.group("Headers:");
  for (const [k, v] of res.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().json());
      break;
    case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger.log(`<${contentType}>`);
      break;
    case matchContentType(res, "text/*"):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}

// node_modules/creem/dist/esm/sdk/sdk.js
var Creem = class extends ClientSDK {
  /**
   * Retrieve a product
   */
  async retrieveProduct(request, options) {
    return unwrapAsync(retrieveProduct(this, request, options));
  }
  /**
   * Creates a new product.
   */
  async createProduct(request, options) {
    return unwrapAsync(createProduct(this, request, options));
  }
  /**
   * List all products
   */
  async searchProducts(request, options) {
    return unwrapAsync(searchProducts(this, request, options));
  }
  /**
   * Retrieve a customer
   */
  async retrieveCustomer(request, options) {
    return unwrapAsync(retrieveCustomer(this, request, options));
  }
  /**
   * Generate Customer Links
   */
  async generateCustomerLinks(request, options) {
    return unwrapAsync(generateCustomerLinks(this, request, options));
  }
  /**
   * Retrieve a subscription
   */
  async retrieveSubscription(request, options) {
    return unwrapAsync(retrieveSubscription(this, request, options));
  }
  /**
   * Cancel a subscription.
   */
  async cancelSubscription(request, options) {
    return unwrapAsync(cancelSubscription(this, request, options));
  }
  /**
   * Update a subscription.
   */
  async updateSubscription(request, options) {
    return unwrapAsync(updateSubscription(this, request, options));
  }
  /**
   * Upgrade a subscription to a different product
   */
  async upgradeSubscription(request, options) {
    return unwrapAsync(upgradeSubscription(this, request, options));
  }
  /**
   * Retrieve a new checkout session.
   */
  async retrieveCheckout(request, options) {
    return unwrapAsync(retrieveCheckout(this, request, options));
  }
  /**
   * Creates a new checkout session.
   */
  async createCheckout(request, options) {
    return unwrapAsync(createCheckout(this, request, options));
  }
  /**
   * Activates a license key.
   */
  async activateLicense(request, options) {
    return unwrapAsync(activateLicense(this, request, options));
  }
  /**
   * Deactivate a license key instance.
   */
  async deactivateLicense(request, options) {
    return unwrapAsync(deactivateLicense(this, request, options));
  }
  /**
   * Validates a license key or instance.
   */
  async validateLicense(request, options) {
    return unwrapAsync(validateLicense(this, request, options));
  }
  /**
   * Retrieve discount
   */
  async retrieveDiscount(request, options) {
    return unwrapAsync(retrieveDiscount(this, request, options));
  }
  /**
   * Create a discount.
   */
  async createDiscount(request, options) {
    return unwrapAsync(createDiscount(this, request, options));
  }
  /**
   * Delete a discount.
   */
  async deleteDiscount(request, options) {
    return unwrapAsync(deleteDiscount(this, request, options));
  }
  /**
   * List all transactions
   */
  async searchTransactions(request, options) {
    return unwrapAsync(searchTransactions(this, request, options));
  }
};
export {
  Creem,
  SDK_METADATA,
  ServerList,
  files_exports as files,
  serverURLFromOptions
};
//# sourceMappingURL=creem.js.map
