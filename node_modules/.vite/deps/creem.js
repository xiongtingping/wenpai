import {
  ZodError,
  _instanceof,
  any,
  array,
  boolean,
  coerce_exports,
  date,
  lazy,
  nativeEnum,
  nullable,
  number,
  object,
  record,
  string,
  union
} from "./chunk-SL6LE3BH.js";
import {
  __export
} from "./chunk-OL46QLBJ.js";

// node_modules/creem/dist/esm/lib/url.js
var hasOwn = Object.prototype.hasOwnProperty;
function pathToFunc(pathPattern, options) {
  const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
  return function buildURLPath(params = {}) {
    return pathPattern.replace(paramRE, function(_, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }
      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Parameter '${placeholder}' must be a string or number`);
      }
      return (options == null ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
    });
  };
}

// node_modules/creem/dist/esm/lib/config.js
var ServerList = [
  "https://api.creem.io",
  "https://test-api.creem.io",
  "http://localhost:8000"
];
function serverURLFromOptions(options) {
  let serverURL = options.serverURL;
  const params = {};
  if (!serverURL) {
    const serverIdx = options.serverIdx ?? 0;
    if (serverIdx < 0 || serverIdx >= ServerList.length) {
      throw new Error(`Invalid server index ${serverIdx}`);
    }
    serverURL = ServerList[serverIdx] || "";
  }
  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}
var SDK_METADATA = {
  language: "typescript",
  openapiDocVersion: "v1",
  sdkVersion: "0.3.37",
  genVersion: "2.599.0",
  userAgent: "speakeasy-sdk/typescript 0.3.37 2.599.0 v1 creem"
};

// node_modules/creem/dist/esm/lib/files.js
var files_exports = {};
__export(files_exports, {
  readableStreamToArrayBuffer: () => readableStreamToArrayBuffer
});
async function readableStreamToArrayBuffer(readable) {
  const reader = readable.getReader();
  const chunks = [];
  let totalLength = 0;
  let done = false;
  while (!done) {
    const { value, done: doneReading } = await reader.read();
    if (doneReading) {
      done = true;
    } else {
      chunks.push(value);
      totalLength += value.length;
    }
  }
  const concatenatedChunks = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    concatenatedChunks.set(chunk, offset);
    offset += chunk.length;
  }
  return concatenatedChunks.buffer;
}

// node_modules/creem/dist/esm/lib/base64.js
function bytesToBase64(u8arr) {
  return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function stringToBase64(str) {
  return bytesToBase64(stringToBytes(str));
}
var zodOutbound = _instanceof(Uint8Array).or(string().transform(stringToBytes));
var zodInbound = _instanceof(Uint8Array).or(string().transform(bytesFromBase64));

// node_modules/creem/dist/esm/lib/is-plain-object.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/creem/dist/esm/lib/encodings.js
var EncodingError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EncodingError";
  }
};
function formEncoder(sep) {
  return (key, value, options) => {
    let out = "";
    const pairs = (options == null ? void 0 : options.explode) ? explode(key, value) : [[key, value]];
    if (pairs.every(([_, v]) => v == null)) {
      return;
    }
    const encodeString = (v) => {
      return (options == null ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v) => encodeString(serializeValue(v));
    const encodedSep = encodeString(sep);
    pairs.forEach(([pk, pv]) => {
      var _a2, _b;
      let tmp = "";
      let encValue = null;
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = (_a2 = mapDefined(pv, (v) => `${encodeValue(v)}`)) == null ? void 0 : _a2.join(encodedSep);
      } else if (isPlainObject(pv)) {
        encValue = (_b = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
        })) == null ? void 0 : _b.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }
      if (encValue == null) {
        return;
      }
      tmp = `${encodeString(pk)}=${encValue}`;
      if (!tmp || tmp === "=") {
        return;
      }
      out += `&${tmp}`;
    });
    return out.slice(1);
  };
}
var encodeForm = formEncoder(",");
var encodeSpaceDelimited = formEncoder(" ");
var encodePipeDelimited = formEncoder("|");
function encodeDeepObject(key, value, options) {
  if (value == null) {
    return;
  }
  if (!isPlainObject(value)) {
    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
  }
  return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
  if (value == null) {
    return;
  }
  let out = "";
  const encodeString = (v) => {
    return (options == null ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
  };
  if (!isPlainObject(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }
  Object.entries(value).forEach(([ck, cv]) => {
    var _a2;
    if (cv == null) {
      return;
    }
    const pk = `${key}[${ck}]`;
    if (isPlainObject(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);
      out += objOut == null ? "" : `&${objOut}`;
      return;
    }
    const pairs = Array.isArray(cv) ? cv : [cv];
    const encoded = (_a2 = mapDefined(pairs, (v) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
    })) == null ? void 0 : _a2.join("&");
    out += encoded == null ? "" : `&${encoded}`;
  });
  return out.slice(1);
}
function encodeJSON(key, value, options) {
  if (typeof value === "undefined") {
    return;
  }
  const encodeString = (v) => {
    return (options == null ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
  };
  const encVal = encodeString(JSON.stringify(value, jsonReplacer));
  return (options == null ? void 0 : options.explode) ? encVal : `${encodeString(key)}=${encVal}`;
}
var encodeSimple = (key, value, options) => {
  let out = "";
  const pairs = (options == null ? void 0 : options.explode) ? explode(key, value) : [[key, value]];
  if (pairs.every(([_, v]) => v == null)) {
    return;
  }
  const encodeString = (v) => {
    return (options == null ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
  };
  const encodeValue = (v) => encodeString(serializeValue(v));
  pairs.forEach(([pk, pv]) => {
    var _a2;
    let tmp = "";
    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      tmp = (_a2 = mapDefined(pv, (v) => `${encodeValue(v)}`)) == null ? void 0 : _a2.join(",");
    } else if (isPlainObject(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
        return `,${encodeString(k)},${encodeValue(v)}`;
      });
      tmp = mapped == null ? void 0 : mapped.join("").slice(1);
    } else {
      const k = (options == null ? void 0 : options.explode) && isPlainObject(value) ? `${pk}=` : "";
      tmp = `${k}${encodeValue(pv)}`;
    }
    out += tmp ? `,${tmp}` : "";
  });
  return out.slice(1);
};
function explode(key, value) {
  if (Array.isArray(value)) {
    return value.map((v) => [key, v]);
  } else if (isPlainObject(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k, v]) => [k, v]);
  } else {
    return [[key, value]];
  }
}
function serializeValue(value) {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }
  return `${value}`;
}
function jsonReplacer(_, value) {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}
function mapDefined(inp, mapper) {
  const res = inp.reduce((acc, v) => {
    if (v == null) {
      return acc;
    }
    const m = mapper(v);
    if (m == null) {
      return acc;
    }
    acc.push(m);
    return acc;
  }, []);
  return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
  const acc = [];
  for (const [k, v] of inp) {
    if (v == null) {
      continue;
    }
    const m = mapper([k, v]);
    if (m == null) {
      continue;
    }
    acc.push(m);
  }
  return acc.length ? acc : null;
}
function queryJoin(...args) {
  return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
  const bulkEncode = function(values, options) {
    const opts = {
      ...options,
      explode: (options == null ? void 0 : options.explode) ?? true,
      charEncoding: (options == null ? void 0 : options.charEncoding) ?? "percent"
    };
    const encoded = Object.entries(values).map(([key, value]) => {
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };
  return bulkEncode;
}
var encodeJSONQuery = queryEncoder(encodeJSON);
var encodeFormQuery = queryEncoder(encodeForm);
var encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
var encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
var encodeDeepObjectQuery = queryEncoder(encodeDeepObject);

// node_modules/creem/dist/esm/models/errors/apierror.js
var APIError = class extends Error {
  constructor(message, rawResponse, body = "") {
    const statusCode = rawResponse.status;
    const contentType = rawResponse.headers.get("content-type") || "";
    const bodyString = body.length > 0 ? `
${body}` : "";
    super(`${message}: Status ${statusCode} Content-Type ${contentType} Body ${bodyString}`);
    this.rawResponse = rawResponse;
    this.body = body;
    this.statusCode = statusCode;
    this.contentType = contentType;
    this.name = "APIError";
  }
};

// node_modules/creem/dist/esm/lib/http.js
var DEFAULT_FETCHER = (input, init) => {
  if (init == null) {
    return fetch(input);
  } else {
    return fetch(input, init);
  }
};
var HTTPClient = class _HTTPClient {
  constructor(options = {}) {
    this.options = options;
    this.requestHooks = [];
    this.requestErrorHooks = [];
    this.responseHooks = [];
    this.fetcher = options.fetcher || DEFAULT_FETCHER;
  }
  async request(request) {
    let req = request;
    for (const hook of this.requestHooks) {
      const nextRequest = await hook(req);
      if (nextRequest) {
        req = nextRequest;
      }
    }
    try {
      const res = await this.fetcher(req);
      for (const hook of this.responseHooks) {
        await hook(res, req);
      }
      return res;
    } catch (err) {
      for (const hook of this.requestErrorHooks) {
        await hook(err, req);
      }
      throw err;
    }
  }
  addHook(...args) {
    if (args[0] === "beforeRequest") {
      this.requestHooks.push(args[1]);
    } else if (args[0] === "requestError") {
      this.requestErrorHooks.push(args[1]);
    } else if (args[0] === "response") {
      this.responseHooks.push(args[1]);
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    return this;
  }
  removeHook(...args) {
    let target;
    if (args[0] === "beforeRequest") {
      target = this.requestHooks;
    } else if (args[0] === "requestError") {
      target = this.requestErrorHooks;
    } else if (args[0] === "response") {
      target = this.responseHooks;
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    const index = target.findIndex((v) => v === args[1]);
    if (index >= 0) {
      target.splice(index, 1);
    }
    return this;
  }
  clone() {
    const child = new _HTTPClient(this.options);
    child.requestHooks = this.requestHooks.slice();
    child.requestErrorHooks = this.requestErrorHooks.slice();
    child.responseHooks = this.responseHooks.slice();
    return child;
  }
};
var mediaParamSeparator = /\s*;\s*/g;
function matchContentType(response, pattern) {
  var _a2;
  if (pattern === "*") {
    return true;
  }
  let contentType = ((_a2 = response.headers.get("content-type")) == null ? void 0 : _a2.trim()) || "application/octet-stream";
  contentType = contentType.toLowerCase();
  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;
  if (wantType.split("/").length !== 2) {
    return false;
  }
  const gotParts = contentType.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;
  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }
  if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
    return false;
  }
  if (gotParams.length < wantParams.length) {
    return false;
  }
  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }
  return true;
}
var codeRangeRE = new RegExp("^[0-9]xx$", "i");
function matchStatusCode(response, codes) {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }
  return expectedCodes.some((ec) => {
    const code = `${ec}`;
    if (code === "default") {
      return true;
    }
    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
function matchResponse(response, code, contentTypePattern) {
  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
function isConnectionError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
  const isBunErr = "name" in err && err.name === "ConnectionError";
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
function isTimeoutError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
function isAbortError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}

// node_modules/creem/dist/esm/models/errors/sdkvalidationerror.js
var SDKValidationError = class extends Error {
  constructor(message, cause, rawValue) {
    super(`${message}: ${cause}`);
    this.name = "SDKValidationError";
    this.cause = cause;
    this.rawValue = rawValue;
    this.rawMessage = message;
  }
  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  pretty() {
    if (this.cause instanceof ZodError) {
      return `${this.rawMessage}
${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
};
function formatZodError(err, level = 0) {
  let pre = "  ".repeat(level);
  pre = level > 0 ? `│${pre}` : pre;
  pre += " ".repeat(level);
  let message = "";
  const append = (str) => message += `
${pre}${str}`;
  const len = err.issues.length;
  const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
  if (len) {
    append(`┌ ${headline}:`);
  }
  for (const issue of err.issues) {
    let path = issue.path.join(".");
    path = path ? `<root>.${path}` : "<root>";
    append(`│ • [${path}]: ${issue.message} (${issue.code})`);
    switch (issue.code) {
      case "invalid_literal":
      case "invalid_type": {
        append(`│     Want: ${issue.expected}`);
        append(`│      Got: ${issue.received}`);
        break;
      }
      case "unrecognized_keys": {
        append(`│     Keys: ${issue.keys.join(", ")}`);
        break;
      }
      case "invalid_enum_value": {
        append(`│     Allowed: ${issue.options.join(", ")}`);
        append(`│         Got: ${issue.received}`);
        break;
      }
      case "invalid_union_discriminator": {
        append(`│     Allowed: ${issue.options.join(", ")}`);
        break;
      }
      case "invalid_union": {
        const len2 = issue.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len2} union members:`);
        issue.unionErrors.forEach((err2, i) => {
          append(`│   ✖︎ Member ${i + 1} of ${len2}`);
          append(`${formatZodError(err2, level + 1)}`);
        });
      }
    }
  }
  if (err.issues.length) {
    append(`└─*`);
  }
  return message.slice(1);
}

// node_modules/creem/dist/esm/types/fp.js
function OK(value) {
  return { ok: true, value };
}
function ERR(error) {
  return { ok: false, error };
}
async function unwrapAsync(pr) {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}

// node_modules/creem/dist/esm/lib/schemas.js
function safeParse(rawValue, fn, errorMessage) {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}

// node_modules/creem/dist/esm/lib/matchers.js
var DEFAULT_CONTENT_TYPES = {
  jsonl: "application/jsonl",
  json: "application/json",
  text: "text/plain",
  bytes: "application/octet-stream",
  stream: "application/octet-stream",
  sse: "text/event-stream",
  nil: "*",
  fail: "*"
};
function json(codes, schema, options) {
  return { ...options, enc: "json", codes, schema };
}
function fail(codes) {
  return { enc: "fail", codes };
}
function match(...matchers) {
  return async function matchFunc(response, options) {
    let raw;
    let matcher;
    for (const match2 of matchers) {
      const { codes } = match2;
      const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match2;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match2;
        break;
      }
    }
    if (!matcher) {
      const responseBody = await response.text();
      return [{
        ok: false,
        error: new APIError("Unexpected API response status or content-type", response, responseBody)
      }, responseBody];
    }
    const encoding = matcher.enc;
    switch (encoding) {
      case "json":
        raw = await response.json();
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        raw = await response.text();
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        raw = await discardResponseBody(response);
        break;
      case "fail":
        raw = await response.text();
        break;
      default:
        encoding;
        throw new Error(`Unsupported response type: ${encoding}`);
    }
    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new APIError("API error occurred", response, typeof raw === "string" ? raw : "")
      }, raw];
    }
    const resultKey = matcher.key || (options == null ? void 0 : options.resultKey);
    let data;
    if ("err" in matcher) {
      data = {
        ...options == null ? void 0 : options.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject(raw) ? raw : null
      };
    } else if (resultKey) {
      data = {
        ...options == null ? void 0 : options.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        [resultKey]: raw
      };
    } else if (matcher.hdrs) {
      data = {
        ...options == null ? void 0 : options.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject(raw) ? raw : null
      };
    } else {
      data = raw;
    }
    if ("err" in matcher) {
      const result = safeParse(data, (v) => matcher.schema.parse(v), "Response validation failed");
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParse(data, (v) => matcher.schema.parse(v), "Response validation failed"),
        raw
      ];
    }
  };
}
var headerValRE = /, */;
function unpackHeaders(headers) {
  const out = {};
  for (const [k, v] of headers.entries()) {
    out[k] = v.split(headerValRE);
  }
  return out;
}
async function discardResponseBody(res) {
  var _a2;
  const reader = (_a2 = res.body) == null ? void 0 : _a2.getReader();
  if (reader == null) {
    return;
  }
  try {
    let done = false;
    while (!done) {
      const res2 = await reader.read();
      done = res2.done;
    }
  } finally {
    reader.releaseLock();
  }
}

// node_modules/creem/dist/esm/lib/primitives.js
function remap(inp, mappings) {
  let out = {};
  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }
  for (const [k, v] of Object.entries(inp)) {
    const j = mappings[k];
    if (j === null) {
      continue;
    }
    out[j ?? k] = v;
  }
  return out;
}
function compactMap(values) {
  const out = {};
  for (const [k, v] of Object.entries(values)) {
    if (typeof v !== "undefined") {
      out[k] = v;
    }
  }
  return out;
}

// node_modules/creem/dist/esm/models/components/activatelicenserequestentity.js
var ActivateLicenseRequestEntity$inboundSchema = object({
  key: string(),
  instance_name: string()
}).transform((v) => {
  return remap(v, {
    "instance_name": "instanceName"
  });
});
var ActivateLicenseRequestEntity$outboundSchema = object({
  key: string(),
  instanceName: string()
}).transform((v) => {
  return remap(v, {
    instanceName: "instance_name"
  });
});
var ActivateLicenseRequestEntity$;
(function(ActivateLicenseRequestEntity$2) {
  ActivateLicenseRequestEntity$2.inboundSchema = ActivateLicenseRequestEntity$inboundSchema;
  ActivateLicenseRequestEntity$2.outboundSchema = ActivateLicenseRequestEntity$outboundSchema;
})(ActivateLicenseRequestEntity$ || (ActivateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerentity.js
var CustomerEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var CustomerEntityMode$inboundSchema = nativeEnum(CustomerEntityMode);
var CustomerEntityMode$outboundSchema = CustomerEntityMode$inboundSchema;
var CustomerEntityMode$;
(function(CustomerEntityMode$2) {
  CustomerEntityMode$2.inboundSchema = CustomerEntityMode$inboundSchema;
  CustomerEntityMode$2.outboundSchema = CustomerEntityMode$outboundSchema;
})(CustomerEntityMode$ || (CustomerEntityMode$ = {}));
var CustomerEntity$inboundSchema = object({
  id: string(),
  mode: CustomerEntityMode$inboundSchema,
  object: string(),
  email: string(),
  name: string().optional(),
  country: string(),
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var CustomerEntity$outboundSchema = object({
  id: string(),
  mode: CustomerEntityMode$outboundSchema,
  object: string(),
  email: string(),
  name: string().optional(),
  country: string(),
  createdAt: date().transform((v) => v.toISOString()),
  updatedAt: date().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var CustomerEntity$;
(function(CustomerEntity$2) {
  CustomerEntity$2.inboundSchema = CustomerEntity$inboundSchema;
  CustomerEntity$2.outboundSchema = CustomerEntity$outboundSchema;
})(CustomerEntity$ || (CustomerEntity$ = {}));

// node_modules/creem/dist/esm/models/components/text.js
var Text$inboundSchema = object({
  max_length: number().optional(),
  min_length: number().optional()
}).transform((v) => {
  return remap(v, {
    "max_length": "maxLength",
    "min_length": "minLength"
  });
});
var Text$outboundSchema = object({
  maxLength: number().optional(),
  minLength: number().optional()
}).transform((v) => {
  return remap(v, {
    maxLength: "max_length",
    minLength: "min_length"
  });
});
var Text$;
(function(Text$2) {
  Text$2.inboundSchema = Text$inboundSchema;
  Text$2.outboundSchema = Text$outboundSchema;
})(Text$ || (Text$ = {}));

// node_modules/creem/dist/esm/models/components/customfield.js
var CustomField$inboundSchema = object({
  type: string(),
  key: string(),
  label: string(),
  optional: boolean().optional(),
  text: Text$inboundSchema.optional()
});
var CustomField$outboundSchema = object({
  type: string(),
  key: string(),
  label: string(),
  optional: boolean().optional(),
  text: Text$outboundSchema.optional()
});
var CustomField$;
(function(CustomField$2) {
  CustomField$2.inboundSchema = CustomField$inboundSchema;
  CustomField$2.outboundSchema = CustomField$outboundSchema;
})(CustomField$ || (CustomField$ = {}));

// node_modules/creem/dist/esm/models/components/orderentity.js
var OrderEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var OrderEntityStatus = {
  Pending: "pending",
  Paid: "paid"
};
var OrderEntityType = {
  Recurring: "recurring",
  Onetime: "onetime"
};
var OrderEntityMode$inboundSchema = nativeEnum(OrderEntityMode);
var OrderEntityMode$outboundSchema = OrderEntityMode$inboundSchema;
var OrderEntityMode$;
(function(OrderEntityMode$2) {
  OrderEntityMode$2.inboundSchema = OrderEntityMode$inboundSchema;
  OrderEntityMode$2.outboundSchema = OrderEntityMode$outboundSchema;
})(OrderEntityMode$ || (OrderEntityMode$ = {}));
var OrderEntityStatus$inboundSchema = nativeEnum(OrderEntityStatus);
var OrderEntityStatus$outboundSchema = OrderEntityStatus$inboundSchema;
var OrderEntityStatus$;
(function(OrderEntityStatus$2) {
  OrderEntityStatus$2.inboundSchema = OrderEntityStatus$inboundSchema;
  OrderEntityStatus$2.outboundSchema = OrderEntityStatus$outboundSchema;
})(OrderEntityStatus$ || (OrderEntityStatus$ = {}));
var OrderEntityType$inboundSchema = nativeEnum(OrderEntityType);
var OrderEntityType$outboundSchema = OrderEntityType$inboundSchema;
var OrderEntityType$;
(function(OrderEntityType$2) {
  OrderEntityType$2.inboundSchema = OrderEntityType$inboundSchema;
  OrderEntityType$2.outboundSchema = OrderEntityType$outboundSchema;
})(OrderEntityType$ || (OrderEntityType$ = {}));
var OrderEntity$inboundSchema = object({
  id: string(),
  mode: OrderEntityMode$inboundSchema,
  object: string(),
  customer: string().optional(),
  product: string(),
  transaction: string().optional(),
  discount: string().optional(),
  amount: number(),
  sub_total: number().optional(),
  tax_amount: number().optional(),
  discount_amount: number().optional(),
  amount_due: number().optional(),
  amount_paid: number().optional(),
  currency: string(),
  fx_amount: number().optional(),
  fx_currency: string().optional(),
  fx_rate: number().optional(),
  status: OrderEntityStatus$inboundSchema,
  type: OrderEntityType$inboundSchema,
  affiliate: string().optional(),
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "sub_total": "subTotal",
    "tax_amount": "taxAmount",
    "discount_amount": "discountAmount",
    "amount_due": "amountDue",
    "amount_paid": "amountPaid",
    "fx_amount": "fxAmount",
    "fx_currency": "fxCurrency",
    "fx_rate": "fxRate",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var OrderEntity$outboundSchema = object({
  id: string(),
  mode: OrderEntityMode$outboundSchema,
  object: string(),
  customer: string().optional(),
  product: string(),
  transaction: string().optional(),
  discount: string().optional(),
  amount: number(),
  subTotal: number().optional(),
  taxAmount: number().optional(),
  discountAmount: number().optional(),
  amountDue: number().optional(),
  amountPaid: number().optional(),
  currency: string(),
  fxAmount: number().optional(),
  fxCurrency: string().optional(),
  fxRate: number().optional(),
  status: OrderEntityStatus$outboundSchema,
  type: OrderEntityType$outboundSchema,
  affiliate: string().optional(),
  createdAt: date().transform((v) => v.toISOString()),
  updatedAt: date().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    subTotal: "sub_total",
    taxAmount: "tax_amount",
    discountAmount: "discount_amount",
    amountDue: "amount_due",
    amountPaid: "amount_paid",
    fxAmount: "fx_amount",
    fxCurrency: "fx_currency",
    fxRate: "fx_rate",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var OrderEntity$;
(function(OrderEntity$2) {
  OrderEntity$2.inboundSchema = OrderEntity$inboundSchema;
  OrderEntity$2.outboundSchema = OrderEntity$outboundSchema;
})(OrderEntity$ || (OrderEntity$ = {}));

// node_modules/creem/dist/esm/models/components/featureentity.js
var FeatureEntity$inboundSchema = object({
  id: string(),
  type: string(),
  description: string()
});
var FeatureEntity$outboundSchema = object({
  id: string(),
  type: string(),
  description: string()
});
var FeatureEntity$;
(function(FeatureEntity$2) {
  FeatureEntity$2.inboundSchema = FeatureEntity$inboundSchema;
  FeatureEntity$2.outboundSchema = FeatureEntity$outboundSchema;
})(FeatureEntity$ || (FeatureEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productentity.js
var Mode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var Mode$inboundSchema = nativeEnum(Mode);
var Mode$outboundSchema = Mode$inboundSchema;
var Mode$;
(function(Mode$2) {
  Mode$2.inboundSchema = Mode$inboundSchema;
  Mode$2.outboundSchema = Mode$outboundSchema;
})(Mode$ || (Mode$ = {}));
var ProductEntity$inboundSchema = object({
  id: string(),
  mode: Mode$inboundSchema,
  object: string(),
  name: string(),
  description: string(),
  image_url: string().optional(),
  features: array(FeatureEntity$inboundSchema).optional(),
  price: number(),
  currency: string(),
  billing_type: string(),
  billing_period: string(),
  status: string(),
  tax_mode: string(),
  tax_category: string(),
  product_url: string().optional(),
  default_success_url: nullable(string()).optional(),
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "product_url": "productUrl",
    "default_success_url": "defaultSuccessUrl",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var ProductEntity$outboundSchema = object({
  id: string(),
  mode: Mode$outboundSchema,
  object: string(),
  name: string(),
  description: string(),
  imageUrl: string().optional(),
  features: array(FeatureEntity$outboundSchema).optional(),
  price: number(),
  currency: string(),
  billingType: string(),
  billingPeriod: string(),
  status: string(),
  taxMode: string(),
  taxCategory: string(),
  productUrl: string().optional(),
  defaultSuccessUrl: nullable(string()).optional(),
  createdAt: date().transform((v) => v.toISOString()),
  updatedAt: date().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    productUrl: "product_url",
    defaultSuccessUrl: "default_success_url",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var ProductEntity$;
(function(ProductEntity$2) {
  ProductEntity$2.inboundSchema = ProductEntity$inboundSchema;
  ProductEntity$2.outboundSchema = ProductEntity$outboundSchema;
})(ProductEntity$ || (ProductEntity$ = {}));

// node_modules/creem/dist/esm/models/components/licenseentity.js
var LicenseEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var LicenseEntityStatus = {
  Inactive: "inactive",
  Active: "active",
  Expired: "expired",
  Disabled: "disabled"
};
var LicenseEntityInstanceMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var LicenseEntityInstanceStatus = {
  Active: "active",
  Deactivated: "deactivated"
};
var LicenseEntityMode$inboundSchema = nativeEnum(LicenseEntityMode);
var LicenseEntityMode$outboundSchema = LicenseEntityMode$inboundSchema;
var LicenseEntityMode$;
(function(LicenseEntityMode$2) {
  LicenseEntityMode$2.inboundSchema = LicenseEntityMode$inboundSchema;
  LicenseEntityMode$2.outboundSchema = LicenseEntityMode$outboundSchema;
})(LicenseEntityMode$ || (LicenseEntityMode$ = {}));
var LicenseEntityStatus$inboundSchema = nativeEnum(LicenseEntityStatus);
var LicenseEntityStatus$outboundSchema = LicenseEntityStatus$inboundSchema;
var LicenseEntityStatus$;
(function(LicenseEntityStatus$2) {
  LicenseEntityStatus$2.inboundSchema = LicenseEntityStatus$inboundSchema;
  LicenseEntityStatus$2.outboundSchema = LicenseEntityStatus$outboundSchema;
})(LicenseEntityStatus$ || (LicenseEntityStatus$ = {}));
var ActivationLimit$inboundSchema = object({});
var ActivationLimit$outboundSchema = object({});
var ActivationLimit$;
(function(ActivationLimit$2) {
  ActivationLimit$2.inboundSchema = ActivationLimit$inboundSchema;
  ActivationLimit$2.outboundSchema = ActivationLimit$outboundSchema;
})(ActivationLimit$ || (ActivationLimit$ = {}));
var ExpiresAt$inboundSchema = object({});
var ExpiresAt$outboundSchema = object({});
var ExpiresAt$;
(function(ExpiresAt$2) {
  ExpiresAt$2.inboundSchema = ExpiresAt$inboundSchema;
  ExpiresAt$2.outboundSchema = ExpiresAt$outboundSchema;
})(ExpiresAt$ || (ExpiresAt$ = {}));
var LicenseEntityInstanceMode$inboundSchema = nativeEnum(LicenseEntityInstanceMode);
var LicenseEntityInstanceMode$outboundSchema = LicenseEntityInstanceMode$inboundSchema;
var LicenseEntityInstanceMode$;
(function(LicenseEntityInstanceMode$2) {
  LicenseEntityInstanceMode$2.inboundSchema = LicenseEntityInstanceMode$inboundSchema;
  LicenseEntityInstanceMode$2.outboundSchema = LicenseEntityInstanceMode$outboundSchema;
})(LicenseEntityInstanceMode$ || (LicenseEntityInstanceMode$ = {}));
var LicenseEntityInstanceStatus$inboundSchema = nativeEnum(LicenseEntityInstanceStatus);
var LicenseEntityInstanceStatus$outboundSchema = LicenseEntityInstanceStatus$inboundSchema;
var LicenseEntityInstanceStatus$;
(function(LicenseEntityInstanceStatus$2) {
  LicenseEntityInstanceStatus$2.inboundSchema = LicenseEntityInstanceStatus$inboundSchema;
  LicenseEntityInstanceStatus$2.outboundSchema = LicenseEntityInstanceStatus$outboundSchema;
})(LicenseEntityInstanceStatus$ || (LicenseEntityInstanceStatus$ = {}));
var Instance$inboundSchema = object({
  id: string(),
  mode: LicenseEntityInstanceMode$inboundSchema,
  object: string(),
  name: string(),
  status: LicenseEntityInstanceStatus$inboundSchema,
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "created_at": "createdAt"
  });
});
var Instance$outboundSchema = object({
  id: string(),
  mode: LicenseEntityInstanceMode$outboundSchema,
  object: string(),
  name: string(),
  status: LicenseEntityInstanceStatus$outboundSchema,
  createdAt: date().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    createdAt: "created_at"
  });
});
var Instance$;
(function(Instance$2) {
  Instance$2.inboundSchema = Instance$inboundSchema;
  Instance$2.outboundSchema = Instance$outboundSchema;
})(Instance$ || (Instance$ = {}));
var LicenseEntity$inboundSchema = object({
  id: string(),
  mode: LicenseEntityMode$inboundSchema,
  object: string(),
  status: LicenseEntityStatus$inboundSchema,
  key: string(),
  activation: number(),
  activation_limit: nullable(lazy(() => ActivationLimit$inboundSchema)).optional(),
  expires_at: nullable(lazy(() => ExpiresAt$inboundSchema)).optional(),
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v)),
  instance: nullable(lazy(() => Instance$inboundSchema)).optional()
}).transform((v) => {
  return remap(v, {
    "activation_limit": "activationLimit",
    "expires_at": "expiresAt",
    "created_at": "createdAt"
  });
});
var LicenseEntity$outboundSchema = object({
  id: string(),
  mode: LicenseEntityMode$outboundSchema,
  object: string(),
  status: LicenseEntityStatus$outboundSchema,
  key: string(),
  activation: number(),
  activationLimit: nullable(lazy(() => ActivationLimit$outboundSchema)).optional(),
  expiresAt: nullable(lazy(() => ExpiresAt$outboundSchema)).optional(),
  createdAt: date().transform((v) => v.toISOString()),
  instance: nullable(lazy(() => Instance$outboundSchema)).optional()
}).transform((v) => {
  return remap(v, {
    activationLimit: "activation_limit",
    expiresAt: "expires_at",
    createdAt: "created_at"
  });
});
var LicenseEntity$;
(function(LicenseEntity$2) {
  LicenseEntity$2.inboundSchema = LicenseEntity$inboundSchema;
  LicenseEntity$2.outboundSchema = LicenseEntity$outboundSchema;
})(LicenseEntity$ || (LicenseEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productfeatureentity.js
var ProductFeatureEntity$inboundSchema = object({
  license: LicenseEntity$inboundSchema
});
var ProductFeatureEntity$outboundSchema = object({
  license: LicenseEntity$outboundSchema
});
var ProductFeatureEntity$;
(function(ProductFeatureEntity$2) {
  ProductFeatureEntity$2.inboundSchema = ProductFeatureEntity$inboundSchema;
  ProductFeatureEntity$2.outboundSchema = ProductFeatureEntity$outboundSchema;
})(ProductFeatureEntity$ || (ProductFeatureEntity$ = {}));

// node_modules/creem/dist/esm/models/components/subscriptionitementity.js
var SubscriptionItemEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var SubscriptionItemEntityMode$inboundSchema = nativeEnum(SubscriptionItemEntityMode);
var SubscriptionItemEntityMode$outboundSchema = SubscriptionItemEntityMode$inboundSchema;
var SubscriptionItemEntityMode$;
(function(SubscriptionItemEntityMode$2) {
  SubscriptionItemEntityMode$2.inboundSchema = SubscriptionItemEntityMode$inboundSchema;
  SubscriptionItemEntityMode$2.outboundSchema = SubscriptionItemEntityMode$outboundSchema;
})(SubscriptionItemEntityMode$ || (SubscriptionItemEntityMode$ = {}));
var SubscriptionItemEntity$inboundSchema = object({
  id: string(),
  mode: SubscriptionItemEntityMode$inboundSchema,
  object: string(),
  product_id: string().optional(),
  price_id: string().optional(),
  units: number().optional()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "price_id": "priceId"
  });
});
var SubscriptionItemEntity$outboundSchema = object({
  id: string(),
  mode: SubscriptionItemEntityMode$outboundSchema,
  object: string(),
  productId: string().optional(),
  priceId: string().optional(),
  units: number().optional()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    priceId: "price_id"
  });
});
var SubscriptionItemEntity$;
(function(SubscriptionItemEntity$2) {
  SubscriptionItemEntity$2.inboundSchema = SubscriptionItemEntity$inboundSchema;
  SubscriptionItemEntity$2.outboundSchema = SubscriptionItemEntity$outboundSchema;
})(SubscriptionItemEntity$ || (SubscriptionItemEntity$ = {}));

// node_modules/creem/dist/esm/models/components/transactionentity.js
var TransactionEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var TransactionEntityMode$inboundSchema = nativeEnum(TransactionEntityMode);
var TransactionEntityMode$outboundSchema = TransactionEntityMode$inboundSchema;
var TransactionEntityMode$;
(function(TransactionEntityMode$2) {
  TransactionEntityMode$2.inboundSchema = TransactionEntityMode$inboundSchema;
  TransactionEntityMode$2.outboundSchema = TransactionEntityMode$outboundSchema;
})(TransactionEntityMode$ || (TransactionEntityMode$ = {}));
var TransactionEntity$inboundSchema = object({
  id: string(),
  mode: TransactionEntityMode$inboundSchema,
  object: string(),
  amount: number(),
  amount_paid: number().optional(),
  discount_amount: number().optional(),
  currency: string(),
  type: string(),
  tax_country: string().optional(),
  tax_amount: number().optional(),
  status: string(),
  refunded_amount: nullable(number()).optional(),
  order: nullable(string()).optional(),
  subscription: nullable(string()).optional(),
  customer: nullable(string()).optional(),
  description: string().optional(),
  period_start: number().optional(),
  period_end: number().optional(),
  created_at: number()
}).transform((v) => {
  return remap(v, {
    "amount_paid": "amountPaid",
    "discount_amount": "discountAmount",
    "tax_country": "taxCountry",
    "tax_amount": "taxAmount",
    "refunded_amount": "refundedAmount",
    "period_start": "periodStart",
    "period_end": "periodEnd",
    "created_at": "createdAt"
  });
});
var TransactionEntity$outboundSchema = object({
  id: string(),
  mode: TransactionEntityMode$outboundSchema,
  object: string(),
  amount: number(),
  amountPaid: number().optional(),
  discountAmount: number().optional(),
  currency: string(),
  type: string(),
  taxCountry: string().optional(),
  taxAmount: number().optional(),
  status: string(),
  refundedAmount: nullable(number()).optional(),
  order: nullable(string()).optional(),
  subscription: nullable(string()).optional(),
  customer: nullable(string()).optional(),
  description: string().optional(),
  periodStart: number().optional(),
  periodEnd: number().optional(),
  createdAt: number()
}).transform((v) => {
  return remap(v, {
    amountPaid: "amount_paid",
    discountAmount: "discount_amount",
    taxCountry: "tax_country",
    taxAmount: "tax_amount",
    refundedAmount: "refunded_amount",
    periodStart: "period_start",
    periodEnd: "period_end",
    createdAt: "created_at"
  });
});
var TransactionEntity$;
(function(TransactionEntity$2) {
  TransactionEntity$2.inboundSchema = TransactionEntity$inboundSchema;
  TransactionEntity$2.outboundSchema = TransactionEntity$outboundSchema;
})(TransactionEntity$ || (TransactionEntity$ = {}));

// node_modules/creem/dist/esm/models/components/subscriptionentity.js
var SubscriptionEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var Status = {
  Active: "active",
  Canceled: "canceled",
  Unpaid: "unpaid",
  Paused: "paused",
  Trialing: "trialing"
};
var SubscriptionEntityMode$inboundSchema = nativeEnum(SubscriptionEntityMode);
var SubscriptionEntityMode$outboundSchema = SubscriptionEntityMode$inboundSchema;
var SubscriptionEntityMode$;
(function(SubscriptionEntityMode$2) {
  SubscriptionEntityMode$2.inboundSchema = SubscriptionEntityMode$inboundSchema;
  SubscriptionEntityMode$2.outboundSchema = SubscriptionEntityMode$outboundSchema;
})(SubscriptionEntityMode$ || (SubscriptionEntityMode$ = {}));
var Product$inboundSchema = union([ProductEntity$inboundSchema, string()]);
var Product$outboundSchema = union([ProductEntity$outboundSchema, string()]);
var Product$;
(function(Product$2) {
  Product$2.inboundSchema = Product$inboundSchema;
  Product$2.outboundSchema = Product$outboundSchema;
})(Product$ || (Product$ = {}));
var Customer$inboundSchema = union([CustomerEntity$inboundSchema, string()]);
var Customer$outboundSchema = union([CustomerEntity$outboundSchema, string()]);
var Customer$;
(function(Customer$2) {
  Customer$2.inboundSchema = Customer$inboundSchema;
  Customer$2.outboundSchema = Customer$outboundSchema;
})(Customer$ || (Customer$ = {}));
var Status$inboundSchema = nativeEnum(Status);
var Status$outboundSchema = Status$inboundSchema;
var Status$;
(function(Status$2) {
  Status$2.inboundSchema = Status$inboundSchema;
  Status$2.outboundSchema = Status$outboundSchema;
})(Status$ || (Status$ = {}));
var SubscriptionEntity$inboundSchema = object({
  id: string(),
  mode: SubscriptionEntityMode$inboundSchema,
  object: string(),
  product: union([ProductEntity$inboundSchema, string()]),
  customer: union([CustomerEntity$inboundSchema, string()]),
  items: array(SubscriptionItemEntity$inboundSchema).optional(),
  collection_method: string(),
  status: Status$inboundSchema,
  last_transaction_id: string().optional(),
  last_transaction: TransactionEntity$inboundSchema.optional(),
  last_transaction_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  next_transaction_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  current_period_start_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  current_period_end_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  canceled_at: nullable(string().datetime({ offset: true }).transform((v) => new Date(v))).optional(),
  created_at: string().datetime({ offset: true }).transform((v) => new Date(v)),
  updated_at: string().datetime({ offset: true }).transform((v) => new Date(v))
}).transform((v) => {
  return remap(v, {
    "collection_method": "collectionMethod",
    "last_transaction_id": "lastTransactionId",
    "last_transaction": "lastTransaction",
    "last_transaction_date": "lastTransactionDate",
    "next_transaction_date": "nextTransactionDate",
    "current_period_start_date": "currentPeriodStartDate",
    "current_period_end_date": "currentPeriodEndDate",
    "canceled_at": "canceledAt",
    "created_at": "createdAt",
    "updated_at": "updatedAt"
  });
});
var SubscriptionEntity$outboundSchema = object({
  id: string(),
  mode: SubscriptionEntityMode$outboundSchema,
  object: string(),
  product: union([ProductEntity$outboundSchema, string()]),
  customer: union([CustomerEntity$outboundSchema, string()]),
  items: array(SubscriptionItemEntity$outboundSchema).optional(),
  collectionMethod: string(),
  status: Status$outboundSchema,
  lastTransactionId: string().optional(),
  lastTransaction: TransactionEntity$outboundSchema.optional(),
  lastTransactionDate: date().transform((v) => v.toISOString()).optional(),
  nextTransactionDate: date().transform((v) => v.toISOString()).optional(),
  currentPeriodStartDate: date().transform((v) => v.toISOString()).optional(),
  currentPeriodEndDate: date().transform((v) => v.toISOString()).optional(),
  canceledAt: nullable(date().transform((v) => v.toISOString())).optional(),
  createdAt: date().transform((v) => v.toISOString()),
  updatedAt: date().transform((v) => v.toISOString())
}).transform((v) => {
  return remap(v, {
    collectionMethod: "collection_method",
    lastTransactionId: "last_transaction_id",
    lastTransaction: "last_transaction",
    lastTransactionDate: "last_transaction_date",
    nextTransactionDate: "next_transaction_date",
    currentPeriodStartDate: "current_period_start_date",
    currentPeriodEndDate: "current_period_end_date",
    canceledAt: "canceled_at",
    createdAt: "created_at",
    updatedAt: "updated_at"
  });
});
var SubscriptionEntity$;
(function(SubscriptionEntity$2) {
  SubscriptionEntity$2.inboundSchema = SubscriptionEntity$inboundSchema;
  SubscriptionEntity$2.outboundSchema = SubscriptionEntity$outboundSchema;
})(SubscriptionEntity$ || (SubscriptionEntity$ = {}));

// node_modules/creem/dist/esm/models/components/checkoutentity.js
var CheckoutEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var CheckoutEntityMode$inboundSchema = nativeEnum(CheckoutEntityMode);
var CheckoutEntityMode$outboundSchema = CheckoutEntityMode$inboundSchema;
var CheckoutEntityMode$;
(function(CheckoutEntityMode$2) {
  CheckoutEntityMode$2.inboundSchema = CheckoutEntityMode$inboundSchema;
  CheckoutEntityMode$2.outboundSchema = CheckoutEntityMode$outboundSchema;
})(CheckoutEntityMode$ || (CheckoutEntityMode$ = {}));
var CheckoutEntityProduct$inboundSchema = union([ProductEntity$inboundSchema, string()]);
var CheckoutEntityProduct$outboundSchema = union([ProductEntity$outboundSchema, string()]);
var CheckoutEntityProduct$;
(function(CheckoutEntityProduct$2) {
  CheckoutEntityProduct$2.inboundSchema = CheckoutEntityProduct$inboundSchema;
  CheckoutEntityProduct$2.outboundSchema = CheckoutEntityProduct$outboundSchema;
})(CheckoutEntityProduct$ || (CheckoutEntityProduct$ = {}));
var Subscription$inboundSchema = union([SubscriptionEntity$inboundSchema, string()]);
var Subscription$outboundSchema = union([SubscriptionEntity$outboundSchema, string()]);
var Subscription$;
(function(Subscription$2) {
  Subscription$2.inboundSchema = Subscription$inboundSchema;
  Subscription$2.outboundSchema = Subscription$outboundSchema;
})(Subscription$ || (Subscription$ = {}));
var CheckoutEntityCustomer$inboundSchema = union([CustomerEntity$inboundSchema, string()]);
var CheckoutEntityCustomer$outboundSchema = union([CustomerEntity$outboundSchema, string()]);
var CheckoutEntityCustomer$;
(function(CheckoutEntityCustomer$2) {
  CheckoutEntityCustomer$2.inboundSchema = CheckoutEntityCustomer$inboundSchema;
  CheckoutEntityCustomer$2.outboundSchema = CheckoutEntityCustomer$outboundSchema;
})(CheckoutEntityCustomer$ || (CheckoutEntityCustomer$ = {}));
var CheckoutEntity$inboundSchema = object({
  id: string(),
  mode: CheckoutEntityMode$inboundSchema,
  object: string(),
  status: string(),
  request_id: string().optional(),
  product: union([ProductEntity$inboundSchema, string()]),
  units: number().default(1),
  order: OrderEntity$inboundSchema.optional(),
  subscription: union([SubscriptionEntity$inboundSchema, string()]).optional(),
  customer: union([CustomerEntity$inboundSchema, string()]).optional(),
  custom_fields: array(CustomField$inboundSchema).optional(),
  checkout_url: string().optional(),
  success_url: nullable(string()).optional(),
  feature: array(ProductFeatureEntity$inboundSchema).optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    "request_id": "requestId",
    "custom_fields": "customFields",
    "checkout_url": "checkoutUrl",
    "success_url": "successUrl"
  });
});
var CheckoutEntity$outboundSchema = object({
  id: string(),
  mode: CheckoutEntityMode$outboundSchema,
  object: string(),
  status: string(),
  requestId: string().optional(),
  product: union([ProductEntity$outboundSchema, string()]),
  units: number().default(1),
  order: OrderEntity$outboundSchema.optional(),
  subscription: union([SubscriptionEntity$outboundSchema, string()]).optional(),
  customer: union([CustomerEntity$outboundSchema, string()]).optional(),
  customFields: array(CustomField$outboundSchema).optional(),
  checkoutUrl: string().optional(),
  successUrl: nullable(string()).optional(),
  feature: array(ProductFeatureEntity$outboundSchema).optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    requestId: "request_id",
    customFields: "custom_fields",
    checkoutUrl: "checkout_url",
    successUrl: "success_url"
  });
});
var CheckoutEntity$;
(function(CheckoutEntity$2) {
  CheckoutEntity$2.inboundSchema = CheckoutEntity$inboundSchema;
  CheckoutEntity$2.outboundSchema = CheckoutEntity$outboundSchema;
})(CheckoutEntity$ || (CheckoutEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerrequestentity.js
var CustomerRequestEntity$inboundSchema = object({
  id: string().optional(),
  email: string().optional()
});
var CustomerRequestEntity$outboundSchema = object({
  id: string().optional(),
  email: string().optional()
});
var CustomerRequestEntity$;
(function(CustomerRequestEntity$2) {
  CustomerRequestEntity$2.inboundSchema = CustomerRequestEntity$inboundSchema;
  CustomerRequestEntity$2.outboundSchema = CustomerRequestEntity$outboundSchema;
})(CustomerRequestEntity$ || (CustomerRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customfieldrequestentity.js
var Type = {
  Text: "text"
};
var Type$inboundSchema = nativeEnum(Type);
var Type$outboundSchema = Type$inboundSchema;
var Type$;
(function(Type$2) {
  Type$2.inboundSchema = Type$inboundSchema;
  Type$2.outboundSchema = Type$outboundSchema;
})(Type$ || (Type$ = {}));
var CustomFieldRequestEntity$inboundSchema = object({
  type: Type$inboundSchema,
  key: string(),
  label: string(),
  optional: boolean().optional(),
  text: Text$inboundSchema.optional()
});
var CustomFieldRequestEntity$outboundSchema = object({
  type: Type$outboundSchema,
  key: string(),
  label: string(),
  optional: boolean().optional(),
  text: Text$outboundSchema.optional()
});
var CustomFieldRequestEntity$;
(function(CustomFieldRequestEntity$2) {
  CustomFieldRequestEntity$2.inboundSchema = CustomFieldRequestEntity$inboundSchema;
  CustomFieldRequestEntity$2.outboundSchema = CustomFieldRequestEntity$outboundSchema;
})(CustomFieldRequestEntity$ || (CustomFieldRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/createcheckoutrequest.js
var CreateCheckoutRequest$inboundSchema = object({
  request_id: string().optional(),
  product_id: string(),
  units: number().optional(),
  discount_code: string().optional(),
  customer: CustomerRequestEntity$inboundSchema.optional(),
  custom_field: array(CustomFieldRequestEntity$inboundSchema).optional(),
  success_url: string().optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    "request_id": "requestId",
    "product_id": "productId",
    "discount_code": "discountCode",
    "custom_field": "customField",
    "success_url": "successUrl"
  });
});
var CreateCheckoutRequest$outboundSchema = object({
  requestId: string().optional(),
  productId: string(),
  units: number().optional(),
  discountCode: string().optional(),
  customer: CustomerRequestEntity$outboundSchema.optional(),
  customField: array(CustomFieldRequestEntity$outboundSchema).optional(),
  successUrl: string().optional(),
  metadata: record(any()).optional()
}).transform((v) => {
  return remap(v, {
    requestId: "request_id",
    productId: "product_id",
    discountCode: "discount_code",
    customField: "custom_field",
    successUrl: "success_url"
  });
});
var CreateCheckoutRequest$;
(function(CreateCheckoutRequest$3) {
  CreateCheckoutRequest$3.inboundSchema = CreateCheckoutRequest$inboundSchema;
  CreateCheckoutRequest$3.outboundSchema = CreateCheckoutRequest$outboundSchema;
})(CreateCheckoutRequest$ || (CreateCheckoutRequest$ = {}));

// node_modules/creem/dist/esm/models/components/createcustomerportallinkrequestentity.js
var CreateCustomerPortalLinkRequestEntity$inboundSchema = object({
  customer_id: string()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId"
  });
});
var CreateCustomerPortalLinkRequestEntity$outboundSchema = object({
  customerId: string()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id"
  });
});
var CreateCustomerPortalLinkRequestEntity$;
(function(CreateCustomerPortalLinkRequestEntity$2) {
  CreateCustomerPortalLinkRequestEntity$2.inboundSchema = CreateCustomerPortalLinkRequestEntity$inboundSchema;
  CreateCustomerPortalLinkRequestEntity$2.outboundSchema = CreateCustomerPortalLinkRequestEntity$outboundSchema;
})(CreateCustomerPortalLinkRequestEntity$ || (CreateCustomerPortalLinkRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/creatediscountrequestentity.js
var CreateDiscountRequestEntityType = {
  Percentage: "percentage",
  Fixed: "fixed"
};
var CreateDiscountRequestEntityDuration = {
  Forever: "forever",
  Once: "once",
  Repeating: "repeating"
};
var CreateDiscountRequestEntityType$inboundSchema = nativeEnum(CreateDiscountRequestEntityType);
var CreateDiscountRequestEntityType$outboundSchema = CreateDiscountRequestEntityType$inboundSchema;
var CreateDiscountRequestEntityType$;
(function(CreateDiscountRequestEntityType$2) {
  CreateDiscountRequestEntityType$2.inboundSchema = CreateDiscountRequestEntityType$inboundSchema;
  CreateDiscountRequestEntityType$2.outboundSchema = CreateDiscountRequestEntityType$outboundSchema;
})(CreateDiscountRequestEntityType$ || (CreateDiscountRequestEntityType$ = {}));
var CreateDiscountRequestEntityDuration$inboundSchema = nativeEnum(CreateDiscountRequestEntityDuration);
var CreateDiscountRequestEntityDuration$outboundSchema = CreateDiscountRequestEntityDuration$inboundSchema;
var CreateDiscountRequestEntityDuration$;
(function(CreateDiscountRequestEntityDuration$2) {
  CreateDiscountRequestEntityDuration$2.inboundSchema = CreateDiscountRequestEntityDuration$inboundSchema;
  CreateDiscountRequestEntityDuration$2.outboundSchema = CreateDiscountRequestEntityDuration$outboundSchema;
})(CreateDiscountRequestEntityDuration$ || (CreateDiscountRequestEntityDuration$ = {}));
var CreateDiscountRequestEntity$inboundSchema = object({
  name: string(),
  code: string().optional(),
  type: CreateDiscountRequestEntityType$inboundSchema,
  amount: number().optional(),
  currency: string().optional(),
  percentage: number().optional(),
  expiry_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  max_redemptions: number().optional(),
  duration: CreateDiscountRequestEntityDuration$inboundSchema,
  duration_in_months: number().optional(),
  applies_to_products: array(string())
}).transform((v) => {
  return remap(v, {
    "expiry_date": "expiryDate",
    "max_redemptions": "maxRedemptions",
    "duration_in_months": "durationInMonths",
    "applies_to_products": "appliesToProducts"
  });
});
var CreateDiscountRequestEntity$outboundSchema = object({
  name: string(),
  code: string().optional(),
  type: CreateDiscountRequestEntityType$outboundSchema,
  amount: number().optional(),
  currency: string().optional(),
  percentage: number().optional(),
  expiryDate: date().transform((v) => v.toISOString()).optional(),
  maxRedemptions: number().optional(),
  duration: CreateDiscountRequestEntityDuration$outboundSchema,
  durationInMonths: number().optional(),
  appliesToProducts: array(string())
}).transform((v) => {
  return remap(v, {
    expiryDate: "expiry_date",
    maxRedemptions: "max_redemptions",
    durationInMonths: "duration_in_months",
    appliesToProducts: "applies_to_products"
  });
});
var CreateDiscountRequestEntity$;
(function(CreateDiscountRequestEntity$2) {
  CreateDiscountRequestEntity$2.inboundSchema = CreateDiscountRequestEntity$inboundSchema;
  CreateDiscountRequestEntity$2.outboundSchema = CreateDiscountRequestEntity$outboundSchema;
})(CreateDiscountRequestEntity$ || (CreateDiscountRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/createproductrequestentity.js
var CreateProductRequestEntity$inboundSchema = object({
  name: string(),
  description: string().optional(),
  image_url: string().optional(),
  price: number().int(),
  currency: string(),
  billing_type: string(),
  billing_period: string().optional(),
  tax_mode: string().optional(),
  tax_category: string().optional(),
  default_success_url: string().optional(),
  custom_field: array(CustomFieldRequestEntity$inboundSchema).optional()
}).transform((v) => {
  return remap(v, {
    "image_url": "imageUrl",
    "billing_type": "billingType",
    "billing_period": "billingPeriod",
    "tax_mode": "taxMode",
    "tax_category": "taxCategory",
    "default_success_url": "defaultSuccessUrl",
    "custom_field": "customField"
  });
});
var CreateProductRequestEntity$outboundSchema = object({
  name: string(),
  description: string().optional(),
  imageUrl: string().optional(),
  price: number().int(),
  currency: string(),
  billingType: string(),
  billingPeriod: string().optional(),
  taxMode: string().optional(),
  taxCategory: string().optional(),
  defaultSuccessUrl: string().optional(),
  customField: array(CustomFieldRequestEntity$outboundSchema).optional()
}).transform((v) => {
  return remap(v, {
    imageUrl: "image_url",
    billingType: "billing_type",
    billingPeriod: "billing_period",
    taxMode: "tax_mode",
    taxCategory: "tax_category",
    defaultSuccessUrl: "default_success_url",
    customField: "custom_field"
  });
});
var CreateProductRequestEntity$;
(function(CreateProductRequestEntity$2) {
  CreateProductRequestEntity$2.inboundSchema = CreateProductRequestEntity$inboundSchema;
  CreateProductRequestEntity$2.outboundSchema = CreateProductRequestEntity$outboundSchema;
})(CreateProductRequestEntity$ || (CreateProductRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/customerlinksentity.js
var CustomerLinksEntity$inboundSchema = object({
  customer_portal_link: string()
}).transform((v) => {
  return remap(v, {
    "customer_portal_link": "customerPortalLink"
  });
});
var CustomerLinksEntity$outboundSchema = object({
  customerPortalLink: string()
}).transform((v) => {
  return remap(v, {
    customerPortalLink: "customer_portal_link"
  });
});
var CustomerLinksEntity$;
(function(CustomerLinksEntity$2) {
  CustomerLinksEntity$2.inboundSchema = CustomerLinksEntity$inboundSchema;
  CustomerLinksEntity$2.outboundSchema = CustomerLinksEntity$outboundSchema;
})(CustomerLinksEntity$ || (CustomerLinksEntity$ = {}));

// node_modules/creem/dist/esm/models/components/deactivatelicenserequestentity.js
var DeactivateLicenseRequestEntity$inboundSchema = object({
  key: string(),
  instance_id: string()
}).transform((v) => {
  return remap(v, {
    "instance_id": "instanceId"
  });
});
var DeactivateLicenseRequestEntity$outboundSchema = object({
  key: string(),
  instanceId: string()
}).transform((v) => {
  return remap(v, {
    instanceId: "instance_id"
  });
});
var DeactivateLicenseRequestEntity$;
(function(DeactivateLicenseRequestEntity$2) {
  DeactivateLicenseRequestEntity$2.inboundSchema = DeactivateLicenseRequestEntity$inboundSchema;
  DeactivateLicenseRequestEntity$2.outboundSchema = DeactivateLicenseRequestEntity$outboundSchema;
})(DeactivateLicenseRequestEntity$ || (DeactivateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/discountentity.js
var DiscountEntityMode = {
  Test: "test",
  Prod: "prod",
  Sandbox: "sandbox"
};
var DiscountEntityStatus = {
  Active: "active",
  Draft: "draft",
  Expired: "expired",
  Scheduled: "scheduled"
};
var DiscountEntityType = {
  Percentage: "percentage",
  Fixed: "fixed"
};
var Duration = {
  Forever: "forever",
  Once: "once",
  Repeating: "repeating"
};
var DiscountEntityMode$inboundSchema = nativeEnum(DiscountEntityMode);
var DiscountEntityMode$outboundSchema = DiscountEntityMode$inboundSchema;
var DiscountEntityMode$;
(function(DiscountEntityMode$2) {
  DiscountEntityMode$2.inboundSchema = DiscountEntityMode$inboundSchema;
  DiscountEntityMode$2.outboundSchema = DiscountEntityMode$outboundSchema;
})(DiscountEntityMode$ || (DiscountEntityMode$ = {}));
var DiscountEntityStatus$inboundSchema = nativeEnum(DiscountEntityStatus);
var DiscountEntityStatus$outboundSchema = DiscountEntityStatus$inboundSchema;
var DiscountEntityStatus$;
(function(DiscountEntityStatus$2) {
  DiscountEntityStatus$2.inboundSchema = DiscountEntityStatus$inboundSchema;
  DiscountEntityStatus$2.outboundSchema = DiscountEntityStatus$outboundSchema;
})(DiscountEntityStatus$ || (DiscountEntityStatus$ = {}));
var DiscountEntityType$inboundSchema = nativeEnum(DiscountEntityType);
var DiscountEntityType$outboundSchema = DiscountEntityType$inboundSchema;
var DiscountEntityType$;
(function(DiscountEntityType$2) {
  DiscountEntityType$2.inboundSchema = DiscountEntityType$inboundSchema;
  DiscountEntityType$2.outboundSchema = DiscountEntityType$outboundSchema;
})(DiscountEntityType$ || (DiscountEntityType$ = {}));
var Duration$inboundSchema = nativeEnum(Duration);
var Duration$outboundSchema = Duration$inboundSchema;
var Duration$;
(function(Duration$2) {
  Duration$2.inboundSchema = Duration$inboundSchema;
  Duration$2.outboundSchema = Duration$outboundSchema;
})(Duration$ || (Duration$ = {}));
var DiscountEntity$inboundSchema = object({
  id: string(),
  mode: DiscountEntityMode$inboundSchema,
  object: string(),
  status: DiscountEntityStatus$inboundSchema,
  name: string(),
  code: string(),
  type: DiscountEntityType$inboundSchema,
  amount: number().optional(),
  currency: string().optional(),
  percentage: number().optional(),
  expiry_date: string().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
  max_redemptions: number().optional(),
  duration: Duration$inboundSchema.optional(),
  duration_in_months: number().optional(),
  applies_to_products: array(string()).optional()
}).transform((v) => {
  return remap(v, {
    "expiry_date": "expiryDate",
    "max_redemptions": "maxRedemptions",
    "duration_in_months": "durationInMonths",
    "applies_to_products": "appliesToProducts"
  });
});
var DiscountEntity$outboundSchema = object({
  id: string(),
  mode: DiscountEntityMode$outboundSchema,
  object: string(),
  status: DiscountEntityStatus$outboundSchema,
  name: string(),
  code: string(),
  type: DiscountEntityType$outboundSchema,
  amount: number().optional(),
  currency: string().optional(),
  percentage: number().optional(),
  expiryDate: date().transform((v) => v.toISOString()).optional(),
  maxRedemptions: number().optional(),
  duration: Duration$outboundSchema.optional(),
  durationInMonths: number().optional(),
  appliesToProducts: array(string()).optional()
}).transform((v) => {
  return remap(v, {
    expiryDate: "expiry_date",
    maxRedemptions: "max_redemptions",
    durationInMonths: "duration_in_months",
    appliesToProducts: "applies_to_products"
  });
});
var DiscountEntity$;
(function(DiscountEntity$2) {
  DiscountEntity$2.inboundSchema = DiscountEntity$inboundSchema;
  DiscountEntity$2.outboundSchema = DiscountEntity$outboundSchema;
})(DiscountEntity$ || (DiscountEntity$ = {}));

// node_modules/creem/dist/esm/models/components/paginationentity.js
var PaginationEntity$inboundSchema = object({
  total_records: number(),
  total_pages: number(),
  current_page: number(),
  next_page: nullable(number()),
  prev_page: nullable(number())
}).transform((v) => {
  return remap(v, {
    "total_records": "totalRecords",
    "total_pages": "totalPages",
    "current_page": "currentPage",
    "next_page": "nextPage",
    "prev_page": "prevPage"
  });
});
var PaginationEntity$outboundSchema = object({
  totalRecords: number(),
  totalPages: number(),
  currentPage: number(),
  nextPage: nullable(number()),
  prevPage: nullable(number())
}).transform((v) => {
  return remap(v, {
    totalRecords: "total_records",
    totalPages: "total_pages",
    currentPage: "current_page",
    nextPage: "next_page",
    prevPage: "prev_page"
  });
});
var PaginationEntity$;
(function(PaginationEntity$2) {
  PaginationEntity$2.inboundSchema = PaginationEntity$inboundSchema;
  PaginationEntity$2.outboundSchema = PaginationEntity$outboundSchema;
})(PaginationEntity$ || (PaginationEntity$ = {}));

// node_modules/creem/dist/esm/models/components/productlistentity.js
var ProductListEntity$inboundSchema = object({
  items: array(ProductEntity$inboundSchema),
  pagination: PaginationEntity$inboundSchema
});
var ProductListEntity$outboundSchema = object({
  items: array(ProductEntity$outboundSchema),
  pagination: PaginationEntity$outboundSchema
});
var ProductListEntity$;
(function(ProductListEntity$2) {
  ProductListEntity$2.inboundSchema = ProductListEntity$inboundSchema;
  ProductListEntity$2.outboundSchema = ProductListEntity$outboundSchema;
})(ProductListEntity$ || (ProductListEntity$ = {}));

// node_modules/creem/dist/esm/models/components/transactionlistentity.js
var TransactionListEntity$inboundSchema = object({
  items: array(TransactionEntity$inboundSchema),
  pagination: PaginationEntity$inboundSchema
});
var TransactionListEntity$outboundSchema = object({
  items: array(TransactionEntity$outboundSchema),
  pagination: PaginationEntity$outboundSchema
});
var TransactionListEntity$;
(function(TransactionListEntity$2) {
  TransactionListEntity$2.inboundSchema = TransactionListEntity$inboundSchema;
  TransactionListEntity$2.outboundSchema = TransactionListEntity$outboundSchema;
})(TransactionListEntity$ || (TransactionListEntity$ = {}));

// node_modules/creem/dist/esm/models/components/upsertsubscriptionitementity.js
var UpsertSubscriptionItemEntity$inboundSchema = object({
  id: string().optional(),
  product_id: string().optional(),
  price_id: string().optional(),
  units: number().optional()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "price_id": "priceId"
  });
});
var UpsertSubscriptionItemEntity$outboundSchema = object({
  id: string().optional(),
  productId: string().optional(),
  priceId: string().optional(),
  units: number().optional()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    priceId: "price_id"
  });
});
var UpsertSubscriptionItemEntity$;
(function(UpsertSubscriptionItemEntity$2) {
  UpsertSubscriptionItemEntity$2.inboundSchema = UpsertSubscriptionItemEntity$inboundSchema;
  UpsertSubscriptionItemEntity$2.outboundSchema = UpsertSubscriptionItemEntity$outboundSchema;
})(UpsertSubscriptionItemEntity$ || (UpsertSubscriptionItemEntity$ = {}));

// node_modules/creem/dist/esm/models/components/updatesubscriptionrequestentity.js
var UpdateBehavior = {
  ProrationChargeImmediately: "proration-charge-immediately",
  ProrationCharge: "proration-charge",
  ProrationNone: "proration-none"
};
var UpdateBehavior$inboundSchema = nativeEnum(UpdateBehavior);
var UpdateBehavior$outboundSchema = UpdateBehavior$inboundSchema;
var UpdateBehavior$;
(function(UpdateBehavior$2) {
  UpdateBehavior$2.inboundSchema = UpdateBehavior$inboundSchema;
  UpdateBehavior$2.outboundSchema = UpdateBehavior$outboundSchema;
})(UpdateBehavior$ || (UpdateBehavior$ = {}));
var UpdateSubscriptionRequestEntity$inboundSchema = object({
  items: array(UpsertSubscriptionItemEntity$inboundSchema).optional(),
  update_behavior: UpdateBehavior$inboundSchema.default("proration-charge")
}).transform((v) => {
  return remap(v, {
    "update_behavior": "updateBehavior"
  });
});
var UpdateSubscriptionRequestEntity$outboundSchema = object({
  items: array(UpsertSubscriptionItemEntity$outboundSchema).optional(),
  updateBehavior: UpdateBehavior$outboundSchema.default("proration-charge")
}).transform((v) => {
  return remap(v, {
    updateBehavior: "update_behavior"
  });
});
var UpdateSubscriptionRequestEntity$;
(function(UpdateSubscriptionRequestEntity$2) {
  UpdateSubscriptionRequestEntity$2.inboundSchema = UpdateSubscriptionRequestEntity$inboundSchema;
  UpdateSubscriptionRequestEntity$2.outboundSchema = UpdateSubscriptionRequestEntity$outboundSchema;
})(UpdateSubscriptionRequestEntity$ || (UpdateSubscriptionRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/upgradesubscriptionrequestentity.js
var UpgradeSubscriptionRequestEntityUpdateBehavior = {
  ProrationChargeImmediately: "proration-charge-immediately",
  ProrationCharge: "proration-charge",
  ProrationNone: "proration-none"
};
var UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema = nativeEnum(UpgradeSubscriptionRequestEntityUpdateBehavior);
var UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema;
var UpgradeSubscriptionRequestEntityUpdateBehavior$;
(function(UpgradeSubscriptionRequestEntityUpdateBehavior$2) {
  UpgradeSubscriptionRequestEntityUpdateBehavior$2.inboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema;
  UpgradeSubscriptionRequestEntityUpdateBehavior$2.outboundSchema = UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema;
})(UpgradeSubscriptionRequestEntityUpdateBehavior$ || (UpgradeSubscriptionRequestEntityUpdateBehavior$ = {}));
var UpgradeSubscriptionRequestEntity$inboundSchema = object({
  product_id: string(),
  update_behavior: UpgradeSubscriptionRequestEntityUpdateBehavior$inboundSchema.default("proration-charge-immediately")
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "update_behavior": "updateBehavior"
  });
});
var UpgradeSubscriptionRequestEntity$outboundSchema = object({
  productId: string(),
  updateBehavior: UpgradeSubscriptionRequestEntityUpdateBehavior$outboundSchema.default("proration-charge-immediately")
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    updateBehavior: "update_behavior"
  });
});
var UpgradeSubscriptionRequestEntity$;
(function(UpgradeSubscriptionRequestEntity$2) {
  UpgradeSubscriptionRequestEntity$2.inboundSchema = UpgradeSubscriptionRequestEntity$inboundSchema;
  UpgradeSubscriptionRequestEntity$2.outboundSchema = UpgradeSubscriptionRequestEntity$outboundSchema;
})(UpgradeSubscriptionRequestEntity$ || (UpgradeSubscriptionRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/components/validatelicenserequestentity.js
var ValidateLicenseRequestEntity$inboundSchema = object({
  key: string(),
  instance_id: string()
}).transform((v) => {
  return remap(v, {
    "instance_id": "instanceId"
  });
});
var ValidateLicenseRequestEntity$outboundSchema = object({
  key: string(),
  instanceId: string()
}).transform((v) => {
  return remap(v, {
    instanceId: "instance_id"
  });
});
var ValidateLicenseRequestEntity$;
(function(ValidateLicenseRequestEntity$2) {
  ValidateLicenseRequestEntity$2.inboundSchema = ValidateLicenseRequestEntity$inboundSchema;
  ValidateLicenseRequestEntity$2.outboundSchema = ValidateLicenseRequestEntity$outboundSchema;
})(ValidateLicenseRequestEntity$ || (ValidateLicenseRequestEntity$ = {}));

// node_modules/creem/dist/esm/models/operations/activatelicense.js
var ActivateLicenseRequest$inboundSchema = object({
  "x-api-key": string(),
  ActivateLicenseRequestEntity: ActivateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "ActivateLicenseRequestEntity": "activateLicenseRequestEntity"
  });
});
var ActivateLicenseRequest$outboundSchema = object({
  xApiKey: string(),
  activateLicenseRequestEntity: ActivateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    activateLicenseRequestEntity: "ActivateLicenseRequestEntity"
  });
});
var ActivateLicenseRequest$;
(function(ActivateLicenseRequest$2) {
  ActivateLicenseRequest$2.inboundSchema = ActivateLicenseRequest$inboundSchema;
  ActivateLicenseRequest$2.outboundSchema = ActivateLicenseRequest$outboundSchema;
})(ActivateLicenseRequest$ || (ActivateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/cancelsubscription.js
var CancelSubscriptionRequest$inboundSchema = object({
  id: string(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey"
  });
});
var CancelSubscriptionRequest$outboundSchema = object({
  id: string(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key"
  });
});
var CancelSubscriptionRequest$;
(function(CancelSubscriptionRequest$2) {
  CancelSubscriptionRequest$2.inboundSchema = CancelSubscriptionRequest$inboundSchema;
  CancelSubscriptionRequest$2.outboundSchema = CancelSubscriptionRequest$outboundSchema;
})(CancelSubscriptionRequest$ || (CancelSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/createcheckout.js
var CreateCheckoutRequest$inboundSchema2 = object({
  "x-api-key": string(),
  CreateCheckoutRequest: CreateCheckoutRequest$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateCheckoutRequest": "createCheckoutRequest"
  });
});
var CreateCheckoutRequest$outboundSchema2 = object({
  xApiKey: string(),
  createCheckoutRequest: CreateCheckoutRequest$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createCheckoutRequest: "CreateCheckoutRequest"
  });
});
var CreateCheckoutRequest$2;
(function(CreateCheckoutRequest$3) {
  CreateCheckoutRequest$3.inboundSchema = CreateCheckoutRequest$inboundSchema2;
  CreateCheckoutRequest$3.outboundSchema = CreateCheckoutRequest$outboundSchema2;
})(CreateCheckoutRequest$2 || (CreateCheckoutRequest$2 = {}));

// node_modules/creem/dist/esm/models/operations/creatediscount.js
var CreateDiscountRequest$inboundSchema = object({
  "x-api-key": string(),
  CreateDiscountRequestEntity: CreateDiscountRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateDiscountRequestEntity": "createDiscountRequestEntity"
  });
});
var CreateDiscountRequest$outboundSchema = object({
  xApiKey: string(),
  createDiscountRequestEntity: CreateDiscountRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createDiscountRequestEntity: "CreateDiscountRequestEntity"
  });
});
var CreateDiscountRequest$;
(function(CreateDiscountRequest$2) {
  CreateDiscountRequest$2.inboundSchema = CreateDiscountRequest$inboundSchema;
  CreateDiscountRequest$2.outboundSchema = CreateDiscountRequest$outboundSchema;
})(CreateDiscountRequest$ || (CreateDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/createproduct.js
var CreateProductRequest$inboundSchema = object({
  "x-api-key": string(),
  CreateProductRequestEntity: CreateProductRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateProductRequestEntity": "createProductRequestEntity"
  });
});
var CreateProductRequest$outboundSchema = object({
  xApiKey: string(),
  createProductRequestEntity: CreateProductRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createProductRequestEntity: "CreateProductRequestEntity"
  });
});
var CreateProductRequest$;
(function(CreateProductRequest$2) {
  CreateProductRequest$2.inboundSchema = CreateProductRequest$inboundSchema;
  CreateProductRequest$2.outboundSchema = CreateProductRequest$outboundSchema;
})(CreateProductRequest$ || (CreateProductRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/deactivatelicense.js
var DeactivateLicenseRequest$inboundSchema = object({
  "x-api-key": string(),
  DeactivateLicenseRequestEntity: DeactivateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "DeactivateLicenseRequestEntity": "deactivateLicenseRequestEntity"
  });
});
var DeactivateLicenseRequest$outboundSchema = object({
  xApiKey: string(),
  deactivateLicenseRequestEntity: DeactivateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    deactivateLicenseRequestEntity: "DeactivateLicenseRequestEntity"
  });
});
var DeactivateLicenseRequest$;
(function(DeactivateLicenseRequest$2) {
  DeactivateLicenseRequest$2.inboundSchema = DeactivateLicenseRequest$inboundSchema;
  DeactivateLicenseRequest$2.outboundSchema = DeactivateLicenseRequest$outboundSchema;
})(DeactivateLicenseRequest$ || (DeactivateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/deletediscount.js
var DeleteDiscountRequest$inboundSchema = object({
  id: string(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey"
  });
});
var DeleteDiscountRequest$outboundSchema = object({
  id: string(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key"
  });
});
var DeleteDiscountRequest$;
(function(DeleteDiscountRequest$2) {
  DeleteDiscountRequest$2.inboundSchema = DeleteDiscountRequest$inboundSchema;
  DeleteDiscountRequest$2.outboundSchema = DeleteDiscountRequest$outboundSchema;
})(DeleteDiscountRequest$ || (DeleteDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/generatecustomerlinks.js
var GenerateCustomerLinksRequest$inboundSchema = object({
  "x-api-key": string(),
  CreateCustomerPortalLinkRequestEntity: CreateCustomerPortalLinkRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "CreateCustomerPortalLinkRequestEntity": "createCustomerPortalLinkRequestEntity"
  });
});
var GenerateCustomerLinksRequest$outboundSchema = object({
  xApiKey: string(),
  createCustomerPortalLinkRequestEntity: CreateCustomerPortalLinkRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    createCustomerPortalLinkRequestEntity: "CreateCustomerPortalLinkRequestEntity"
  });
});
var GenerateCustomerLinksRequest$;
(function(GenerateCustomerLinksRequest$2) {
  GenerateCustomerLinksRequest$2.inboundSchema = GenerateCustomerLinksRequest$inboundSchema;
  GenerateCustomerLinksRequest$2.outboundSchema = GenerateCustomerLinksRequest$outboundSchema;
})(GenerateCustomerLinksRequest$ || (GenerateCustomerLinksRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievecheckout.js
var RetrieveCheckoutRequest$inboundSchema = object({
  checkout_id: string(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "checkout_id": "checkoutId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveCheckoutRequest$outboundSchema = object({
  checkoutId: string(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    checkoutId: "checkout_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveCheckoutRequest$;
(function(RetrieveCheckoutRequest$2) {
  RetrieveCheckoutRequest$2.inboundSchema = RetrieveCheckoutRequest$inboundSchema;
  RetrieveCheckoutRequest$2.outboundSchema = RetrieveCheckoutRequest$outboundSchema;
})(RetrieveCheckoutRequest$ || (RetrieveCheckoutRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievecustomer.js
var RetrieveCustomerRequest$inboundSchema = object({
  customer_id: string().optional(),
  email: string().optional(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveCustomerRequest$outboundSchema = object({
  customerId: string().optional(),
  email: string().optional(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveCustomerRequest$;
(function(RetrieveCustomerRequest$2) {
  RetrieveCustomerRequest$2.inboundSchema = RetrieveCustomerRequest$inboundSchema;
  RetrieveCustomerRequest$2.outboundSchema = RetrieveCustomerRequest$outboundSchema;
})(RetrieveCustomerRequest$ || (RetrieveCustomerRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievediscount.js
var RetrieveDiscountRequest$inboundSchema = object({
  discount_id: string().optional(),
  discount_code: string().optional(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "discount_id": "discountId",
    "discount_code": "discountCode",
    "x-api-key": "xApiKey"
  });
});
var RetrieveDiscountRequest$outboundSchema = object({
  discountId: string().optional(),
  discountCode: string().optional(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    discountId: "discount_id",
    discountCode: "discount_code",
    xApiKey: "x-api-key"
  });
});
var RetrieveDiscountRequest$;
(function(RetrieveDiscountRequest$2) {
  RetrieveDiscountRequest$2.inboundSchema = RetrieveDiscountRequest$inboundSchema;
  RetrieveDiscountRequest$2.outboundSchema = RetrieveDiscountRequest$outboundSchema;
})(RetrieveDiscountRequest$ || (RetrieveDiscountRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrieveproduct.js
var RetrieveProductRequest$inboundSchema = object({
  product_id: string(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "product_id": "productId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveProductRequest$outboundSchema = object({
  productId: string(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    productId: "product_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveProductRequest$;
(function(RetrieveProductRequest$2) {
  RetrieveProductRequest$2.inboundSchema = RetrieveProductRequest$inboundSchema;
  RetrieveProductRequest$2.outboundSchema = RetrieveProductRequest$outboundSchema;
})(RetrieveProductRequest$ || (RetrieveProductRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/retrievesubscription.js
var RetrieveSubscriptionRequest$inboundSchema = object({
  subscription_id: string(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "subscription_id": "subscriptionId",
    "x-api-key": "xApiKey"
  });
});
var RetrieveSubscriptionRequest$outboundSchema = object({
  subscriptionId: string(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    subscriptionId: "subscription_id",
    xApiKey: "x-api-key"
  });
});
var RetrieveSubscriptionRequest$;
(function(RetrieveSubscriptionRequest$2) {
  RetrieveSubscriptionRequest$2.inboundSchema = RetrieveSubscriptionRequest$inboundSchema;
  RetrieveSubscriptionRequest$2.outboundSchema = RetrieveSubscriptionRequest$outboundSchema;
})(RetrieveSubscriptionRequest$ || (RetrieveSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/searchproducts.js
var SearchProductsRequest$inboundSchema = object({
  page_number: number().optional(),
  page_size: number().optional(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "page_number": "pageNumber",
    "page_size": "pageSize",
    "x-api-key": "xApiKey"
  });
});
var SearchProductsRequest$outboundSchema = object({
  pageNumber: number().optional(),
  pageSize: number().optional(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    pageNumber: "page_number",
    pageSize: "page_size",
    xApiKey: "x-api-key"
  });
});
var SearchProductsRequest$;
(function(SearchProductsRequest$2) {
  SearchProductsRequest$2.inboundSchema = SearchProductsRequest$inboundSchema;
  SearchProductsRequest$2.outboundSchema = SearchProductsRequest$outboundSchema;
})(SearchProductsRequest$ || (SearchProductsRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/searchtransactions.js
var SearchTransactionsRequest$inboundSchema = object({
  customer_id: string().optional(),
  order_id: string().optional(),
  product_id: string().optional(),
  page_number: number().optional(),
  page_size: number().optional(),
  "x-api-key": string()
}).transform((v) => {
  return remap(v, {
    "customer_id": "customerId",
    "order_id": "orderId",
    "product_id": "productId",
    "page_number": "pageNumber",
    "page_size": "pageSize",
    "x-api-key": "xApiKey"
  });
});
var SearchTransactionsRequest$outboundSchema = object({
  customerId: string().optional(),
  orderId: string().optional(),
  productId: string().optional(),
  pageNumber: number().optional(),
  pageSize: number().optional(),
  xApiKey: string()
}).transform((v) => {
  return remap(v, {
    customerId: "customer_id",
    orderId: "order_id",
    productId: "product_id",
    pageNumber: "page_number",
    pageSize: "page_size",
    xApiKey: "x-api-key"
  });
});
var SearchTransactionsRequest$;
(function(SearchTransactionsRequest$2) {
  SearchTransactionsRequest$2.inboundSchema = SearchTransactionsRequest$inboundSchema;
  SearchTransactionsRequest$2.outboundSchema = SearchTransactionsRequest$outboundSchema;
})(SearchTransactionsRequest$ || (SearchTransactionsRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/updatesubscription.js
var UpdateSubscriptionRequest$inboundSchema = object({
  id: string(),
  "x-api-key": string(),
  UpdateSubscriptionRequestEntity: UpdateSubscriptionRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "UpdateSubscriptionRequestEntity": "updateSubscriptionRequestEntity"
  });
});
var UpdateSubscriptionRequest$outboundSchema = object({
  id: string(),
  xApiKey: string(),
  updateSubscriptionRequestEntity: UpdateSubscriptionRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    updateSubscriptionRequestEntity: "UpdateSubscriptionRequestEntity"
  });
});
var UpdateSubscriptionRequest$;
(function(UpdateSubscriptionRequest$2) {
  UpdateSubscriptionRequest$2.inboundSchema = UpdateSubscriptionRequest$inboundSchema;
  UpdateSubscriptionRequest$2.outboundSchema = UpdateSubscriptionRequest$outboundSchema;
})(UpdateSubscriptionRequest$ || (UpdateSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/upgradesubscription.js
var UpgradeSubscriptionRequest$inboundSchema = object({
  id: string(),
  "x-api-key": string(),
  UpgradeSubscriptionRequestEntity: UpgradeSubscriptionRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "UpgradeSubscriptionRequestEntity": "upgradeSubscriptionRequestEntity"
  });
});
var UpgradeSubscriptionRequest$outboundSchema = object({
  id: string(),
  xApiKey: string(),
  upgradeSubscriptionRequestEntity: UpgradeSubscriptionRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    upgradeSubscriptionRequestEntity: "UpgradeSubscriptionRequestEntity"
  });
});
var UpgradeSubscriptionRequest$;
(function(UpgradeSubscriptionRequest$2) {
  UpgradeSubscriptionRequest$2.inboundSchema = UpgradeSubscriptionRequest$inboundSchema;
  UpgradeSubscriptionRequest$2.outboundSchema = UpgradeSubscriptionRequest$outboundSchema;
})(UpgradeSubscriptionRequest$ || (UpgradeSubscriptionRequest$ = {}));

// node_modules/creem/dist/esm/models/operations/validatelicense.js
var ValidateLicenseRequest$inboundSchema = object({
  "x-api-key": string(),
  ValidateLicenseRequestEntity: ValidateLicenseRequestEntity$inboundSchema
}).transform((v) => {
  return remap(v, {
    "x-api-key": "xApiKey",
    "ValidateLicenseRequestEntity": "validateLicenseRequestEntity"
  });
});
var ValidateLicenseRequest$outboundSchema = object({
  xApiKey: string(),
  validateLicenseRequestEntity: ValidateLicenseRequestEntity$outboundSchema
}).transform((v) => {
  return remap(v, {
    xApiKey: "x-api-key",
    validateLicenseRequestEntity: "ValidateLicenseRequestEntity"
  });
});
var ValidateLicenseRequest$;
(function(ValidateLicenseRequest$2) {
  ValidateLicenseRequest$2.inboundSchema = ValidateLicenseRequest$inboundSchema;
  ValidateLicenseRequest$2.outboundSchema = ValidateLicenseRequest$outboundSchema;
})(ValidateLicenseRequest$ || (ValidateLicenseRequest$ = {}));

// node_modules/creem/dist/esm/types/async.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _APIPromise_promise;
var _APIPromise_unwrapped;
var _a;
var APIPromise = class {
  constructor(p) {
    _APIPromise_promise.set(this, void 0);
    _APIPromise_unwrapped.set(this, void 0);
    this[_a] = "APIPromise";
    __classPrivateFieldSet(this, _APIPromise_promise, p instanceof Promise ? p : Promise.resolve(p), "f");
    __classPrivateFieldSet(this, _APIPromise_unwrapped, p instanceof Promise ? __classPrivateFieldGet(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p[0]), "f");
  }
  then(onfulfilled, onrejected) {
    return __classPrivateFieldGet(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
  }
  catch(onrejected) {
    return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").catch(onrejected);
  }
  finally(onfinally) {
    return __classPrivateFieldGet(this, _APIPromise_unwrapped, "f").finally(onfinally);
  }
  $inspect() {
    return __classPrivateFieldGet(this, _APIPromise_promise, "f");
  }
};
_APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a = Symbol.toStringTag;

// node_modules/creem/dist/esm/funcs/activateLicense.js
function activateLicense(client, request, options) {
  return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
  const parsed = safeParse(request, (value) => ActivateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ActivateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/activate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "activateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/cancelSubscription.js
function cancelSubscription(client, request, options) {
  return new APIPromise($do2(client, request, options));
}
async function $do2(client, request, options) {
  const parsed = safeParse(request, (value) => CancelSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}/cancel")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "cancelSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createCheckout.js
function createCheckout(client, request, options) {
  return new APIPromise($do3(client, request, options));
}
async function $do3(client, request, options) {
  const parsed = safeParse(request, (value) => CreateCheckoutRequest$outboundSchema2.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateCheckoutRequest, {
    explode: true
  });
  const path = pathToFunc("/v1/checkouts")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "createCheckout",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CheckoutEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createDiscount.js
function createDiscount(client, request, options) {
  return new APIPromise($do4(client, request, options));
}
async function $do4(client, request, options) {
  const parsed = safeParse(request, (value) => CreateDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateDiscountRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/discounts")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "createDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/createProduct.js
function createProduct(client, request, options) {
  return new APIPromise($do5(client, request, options));
}
async function $do5(client, request, options) {
  const parsed = safeParse(request, (value) => CreateProductRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateProductRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/products")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "createProduct",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/deactivateLicense.js
function deactivateLicense(client, request, options) {
  return new APIPromise($do6(client, request, options));
}
async function $do6(client, request, options) {
  const parsed = safeParse(request, (value) => DeactivateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DeactivateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/deactivate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "deactivateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/deleteDiscount.js
function deleteDiscount(client, request, options) {
  return new APIPromise($do7(client, request, options));
}
async function $do7(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/discounts/{id}/delete")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "deleteDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "DELETE",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/generateCustomerLinks.js
function generateCustomerLinks(client, request, options) {
  return new APIPromise($do8(client, request, options));
}
async function $do8(client, request, options) {
  const parsed = safeParse(request, (value) => GenerateCustomerLinksRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateCustomerPortalLinkRequestEntity, { explode: true });
  const path = pathToFunc("/v1/customers/billing")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "generateCustomerLinks",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerLinksEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveCheckout.js
function retrieveCheckout(client, request, options) {
  return new APIPromise($do9(client, request, options));
}
async function $do9(client, request, options) {
  const parsed = safeParse(request, (value) => RetrieveCheckoutRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/checkouts")();
  const query = encodeFormQuery({
    "checkout_id": payload.checkout_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "retrieveCheckout",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CheckoutEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveCustomer.js
function retrieveCustomer(client, request, options) {
  return new APIPromise($do10(client, request, options));
}
async function $do10(client, request, options) {
  const parsed = safeParse(request, (value) => RetrieveCustomerRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/customers")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "email": payload.email
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "retrieveCustomer",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, CustomerEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveDiscount.js
function retrieveDiscount(client, request, options) {
  return new APIPromise($do11(client, request, options));
}
async function $do11(client, request, options) {
  const parsed = safeParse(request, (value) => RetrieveDiscountRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/discounts")();
  const query = encodeFormQuery({
    "discount_code": payload.discount_code,
    "discount_id": payload.discount_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "retrieveDiscount",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, DiscountEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveProduct.js
function retrieveProduct(client, request, options) {
  return new APIPromise($do12(client, request, options));
}
async function $do12(client, request, options) {
  const parsed = safeParse(request, (value) => RetrieveProductRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/products")();
  const query = encodeFormQuery({
    "product_id": payload.product_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "retrieveProduct",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/retrieveSubscription.js
function retrieveSubscription(client, request, options) {
  return new APIPromise($do13(client, request, options));
}
async function $do13(client, request, options) {
  const parsed = safeParse(request, (value) => RetrieveSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/subscriptions")();
  const query = encodeFormQuery({
    "subscription_id": payload.subscription_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "retrieveSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/searchProducts.js
function searchProducts(client, request, options) {
  return new APIPromise($do14(client, request, options));
}
async function $do14(client, request, options) {
  const parsed = safeParse(request, (value) => SearchProductsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/products/search")();
  const query = encodeFormQuery({
    "page_number": payload.page_number,
    "page_size": payload.page_size
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "searchProducts",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, ProductListEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/searchTransactions.js
function searchTransactions(client, request, options) {
  return new APIPromise($do15(client, request, options));
}
async function $do15(client, request, options) {
  const parsed = safeParse(request, (value) => SearchTransactionsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const path = pathToFunc("/v1/transactions/search")();
  const query = encodeFormQuery({
    "customer_id": payload.customer_id,
    "order_id": payload.order_id,
    "page_number": payload.page_number,
    "page_size": payload.page_size,
    "product_id": payload.product_id
  });
  const headers = new Headers(compactMap({
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "searchTransactions",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "GET",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    query,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, TransactionListEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/updateSubscription.js
function updateSubscription(client, request, options) {
  return new APIPromise($do16(client, request, options));
}
async function $do16(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateSubscriptionRequestEntity, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "updateSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/upgradeSubscription.js
function upgradeSubscription(client, request, options) {
  return new APIPromise($do17(client, request, options));
}
async function $do17(client, request, options) {
  const parsed = safeParse(request, (value) => UpgradeSubscriptionRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpgradeSubscriptionRequestEntity, {
    explode: true
  });
  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/v1/subscriptions/{id}/upgrade")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "upgradeSubscription",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, SubscriptionEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/funcs/validateLicense.js
function validateLicense(client, request, options) {
  return new APIPromise($do18(client, request, options));
}
async function $do18(client, request, options) {
  const parsed = safeParse(request, (value) => ValidateLicenseRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ValidateLicenseRequestEntity, {
    explode: true
  });
  const path = pathToFunc("/v1/licenses/validate")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-api-key": encodeSimple("x-api-key", payload["x-api-key"], {
      explode: false,
      charEncoding: "none"
    })
  }));
  const context = {
    baseURL: (options == null ? void 0 : options.serverURL) ?? client._baseURL ?? "",
    operationID: "validateLicense",
    oAuth2Scopes: [],
    resolvedSecurity: null,
    securitySource: null,
    retryConfig: (options == null ? void 0 : options.retries) || client._options.retryConfig || { strategy: "none" },
    retryCodes: (options == null ? void 0 : options.retryCodes) || ["429", "500", "502", "503", "504"]
  };
  const requestRes = client._createRequest(context, {
    method: "POST",
    baseURL: options == null ? void 0 : options.serverURL,
    path,
    headers,
    body,
    timeoutMs: (options == null ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const [result] = await match(json(200, LicenseEntity$inboundSchema), fail("4XX"), fail("5XX"))(response);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }
  return [result, { status: "complete", request: req, response }];
}

// node_modules/creem/dist/esm/hooks/hooks.js
var SDKHooks = class {
  constructor() {
    this.sdkInitHooks = [];
    this.beforeCreateRequestHooks = [];
    this.beforeRequestHooks = [];
    this.afterSuccessHooks = [];
    this.afterErrorHooks = [];
    const presetHooks = [];
    for (const hook of presetHooks) {
      if ("sdkInit" in hook) {
        this.registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        this.registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        this.registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        this.registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        this.registerAfterErrorHook(hook);
      }
    }
  }
  registerSDKInitHook(hook) {
    this.sdkInitHooks.push(hook);
  }
  registerBeforeCreateRequestHook(hook) {
    this.beforeCreateRequestHooks.push(hook);
  }
  registerBeforeRequestHook(hook) {
    this.beforeRequestHooks.push(hook);
  }
  registerAfterSuccessHook(hook) {
    this.afterSuccessHooks.push(hook);
  }
  registerAfterErrorHook(hook) {
    this.afterErrorHooks.push(hook);
  }
  sdkInit(opts) {
    return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
  }
  beforeCreateRequest(hookCtx, input) {
    let inp = input;
    for (const hook of this.beforeCreateRequestHooks) {
      inp = hook.beforeCreateRequest(hookCtx, inp);
    }
    return inp;
  }
  async beforeRequest(hookCtx, request) {
    let req = request;
    for (const hook of this.beforeRequestHooks) {
      req = await hook.beforeRequest(hookCtx, req);
    }
    return req;
  }
  async afterSuccess(hookCtx, response) {
    let res = response;
    for (const hook of this.afterSuccessHooks) {
      res = await hook.afterSuccess(hookCtx, res);
    }
    return res;
  }
  async afterError(hookCtx, response, error) {
    let res = response;
    let err = error;
    for (const hook of this.afterErrorHooks) {
      const result = await hook.afterError(hookCtx, res, err);
      res = result.response;
      err = result.error;
    }
    return { response: res, error: err };
  }
};

// node_modules/creem/dist/esm/models/errors/httpclienterrors.js
var HTTPClientError = class extends Error {
  constructor(message, opts) {
    let msg = message;
    if (opts == null ? void 0 : opts.cause) {
      msg += `: ${opts.cause}`;
    }
    super(msg, opts);
    this.name = "HTTPClientError";
    if (typeof this.cause === "undefined") {
      this.cause = opts == null ? void 0 : opts.cause;
    }
  }
};
var UnexpectedClientError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "UnexpectedClientError";
  }
};
var InvalidRequestError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "InvalidRequestError";
  }
};
var RequestAbortedError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestAbortedError";
  }
};
var RequestTimeoutError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "RequestTimeoutError";
  }
};
var ConnectionError = class extends HTTPClientError {
  constructor() {
    super(...arguments);
    this.name = "ConnectionError";
  }
};

// node_modules/creem/dist/esm/lib/dlv.js
function dlv(obj, key, def, p, undef) {
  key = Array.isArray(key) ? key : key.split(".");
  for (p = 0; p < key.length; p++) {
    const k = key[p];
    obj = k != null && obj ? obj[k] : undef;
  }
  return obj === undef ? def : obj;
}

// node_modules/creem/dist/esm/lib/env.js
var envSchema = object({
  CREEM_DEBUG: coerce_exports.boolean().optional()
});
var envMemo = void 0;
function env() {
  if (envMemo) {
    return envMemo;
  }
  envMemo = envSchema.parse(dlv(globalThis, "process.env") ?? dlv(globalThis, "Deno.env") ?? {});
  return envMemo;
}

// node_modules/creem/dist/esm/lib/retries.js
var defaultBackoff = {
  initialInterval: 500,
  maxInterval: 6e4,
  exponent: 1.5,
  maxElapsedTime: 36e5
};
var PermanentError = class _PermanentError extends Error {
  constructor(message, options) {
    let msg = message;
    if (options == null ? void 0 : options.cause) {
      msg += `: ${options.cause}`;
    }
    super(msg, options);
    this.name = "PermanentError";
    if (typeof this.cause === "undefined") {
      this.cause = options == null ? void 0 : options.cause;
    }
    Object.setPrototypeOf(this, _PermanentError.prototype);
  }
};
var TemporaryError = class _TemporaryError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "TemporaryError";
    Object.setPrototypeOf(this, _TemporaryError.prototype);
  }
};
async function retry(fetchFn, options) {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(wrapFetcher(fetchFn, {
        statusCodes: options.statusCodes,
        retryConnectionErrors: !!options.config.retryConnectionErrors
      }), options.config.backoff ?? defaultBackoff);
    default:
      return await fetchFn();
  }
}
function wrapFetcher(fn, options) {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError("Response failed with retryable status code", res);
      }
      return res;
    } catch (err) {
      if (err instanceof TemporaryError) {
        throw err;
      }
      if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
        throw err;
      }
      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}
var codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
function isRetryableResponse(res, statusCodes) {
  const actual = `${res.status}`;
  return statusCodes.some((code) => {
    if (!codeRangeRE2.test(code)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
async function retryBackoff(fn, strategy) {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
  const start = Date.now();
  let x = 0;
  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }
        throw err;
      }
      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }
      if (retryInterval <= 0) {
        retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1e3;
      }
      const d = Math.min(retryInterval, maxInterval);
      await delay(d);
      x++;
    }
  }
}
function retryIntervalFromResponse(res) {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }
  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1e3;
  }
  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }
  return 0;
}
async function delay(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}

// node_modules/creem/dist/esm/lib/sdks.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClientSDK_httpClient;
var _ClientSDK_hooks;
var _ClientSDK_logger;
var gt = typeof globalThis === "undefined" ? null : globalThis;
var webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
var isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
var ClientSDK = class {
  constructor(options = {}) {
    _ClientSDK_httpClient.set(this, void 0);
    _ClientSDK_hooks.set(this, void 0);
    _ClientSDK_logger.set(this, void 0);
    const opt = options;
    if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof SDKHooks) {
      __classPrivateFieldSet2(this, _ClientSDK_hooks, opt.hooks, "f");
    } else {
      __classPrivateFieldSet2(this, _ClientSDK_hooks, new SDKHooks(), "f");
    }
    this._options = { ...options, hooks: __classPrivateFieldGet2(this, _ClientSDK_hooks, "f") };
    const url = serverURLFromOptions(options);
    if (url) {
      url.pathname = url.pathname.replace(/\/+$/, "") + "/";
    }
    const { baseURL, client } = __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").sdkInit({
      baseURL: url,
      client: options.httpClient || new HTTPClient()
    });
    this._baseURL = baseURL;
    __classPrivateFieldSet2(this, _ClientSDK_httpClient, client, "f");
    __classPrivateFieldSet2(this, _ClientSDK_logger, options.debugLogger, "f");
    if (!__classPrivateFieldGet2(this, _ClientSDK_logger, "f") && env().CREEM_DEBUG) {
      __classPrivateFieldSet2(this, _ClientSDK_logger, console, "f");
    }
  }
  _createRequest(context, conf, options) {
    var _a2;
    const { method, path, query, headers: opHeaders, security } = conf;
    const base = conf.baseURL ?? this._baseURL;
    if (!base) {
      return ERR(new InvalidRequestError("No base URL provided for operation"));
    }
    const reqURL = new URL(base);
    const inputURL = new URL(path, reqURL);
    if (path) {
      reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
      reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
    }
    let finalQuery = query || "";
    const secQuery = [];
    for (const [k, v] of Object.entries((security == null ? void 0 : security.queryParams) || {})) {
      const q = encodeForm(k, v, { charEncoding: "percent" });
      if (typeof q !== "undefined") {
        secQuery.push(q);
      }
    }
    if (secQuery.length) {
      finalQuery += `&${secQuery.join("&")}`;
    }
    if (finalQuery) {
      const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
      reqURL.search = `?${q}`;
    }
    const headers = new Headers(opHeaders);
    const username = security == null ? void 0 : security.basic.username;
    const password = security == null ? void 0 : security.basic.password;
    if (username != null || password != null) {
      const encoded = stringToBase64([username || "", password || ""].join(":"));
      headers.set("Authorization", `Basic ${encoded}`);
    }
    const securityHeaders = new Headers((security == null ? void 0 : security.headers) || {});
    for (const [k, v] of securityHeaders) {
      headers.set(k, v);
    }
    let cookie = headers.get("cookie") || "";
    for (const [k, v] of Object.entries((security == null ? void 0 : security.cookies) || {})) {
      cookie += `; ${k}=${v}`;
    }
    cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
    headers.set("cookie", cookie);
    const userHeaders = new Headers((options == null ? void 0 : options.headers) ?? ((_a2 = options == null ? void 0 : options.fetchOptions) == null ? void 0 : _a2.headers));
    for (const [k, v] of userHeaders) {
      headers.set(k, v);
    }
    if (!isBrowserLike) {
      headers.set(conf.uaHeader ?? "user-agent", SDK_METADATA.userAgent);
    }
    const fetchOptions = {
      ...options == null ? void 0 : options.fetchOptions,
      ...options
    };
    if (!(fetchOptions == null ? void 0 : fetchOptions.signal) && conf.timeoutMs && conf.timeoutMs > 0) {
      const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
      fetchOptions.signal = timeoutSignal;
    }
    if (conf.body instanceof ReadableStream) {
      Object.assign(fetchOptions, { duplex: "half" });
    }
    let input;
    try {
      input = __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
        url: reqURL,
        options: {
          ...fetchOptions,
          body: conf.body ?? null,
          headers,
          method
        }
      });
    } catch (err) {
      return ERR(new UnexpectedClientError("Create request hook failed to execute", {
        cause: err
      }));
    }
    return OK(new Request(input.url, input.options));
  }
  async _do(request, options) {
    const { context, errorCodes } = options;
    return retry(async () => {
      const req = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
      await logRequest(__classPrivateFieldGet2(this, _ClientSDK_logger, "f"), req).catch((e) => {
        var _a2;
        return (_a2 = __classPrivateFieldGet2(this, _ClientSDK_logger, "f")) == null ? void 0 : _a2.log("Failed to log request:", e);
      });
      let response = await __classPrivateFieldGet2(this, _ClientSDK_httpClient, "f").request(req);
      try {
        if (matchStatusCode(response, errorCodes)) {
          const result = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").afterError(context, response, null);
          if (result.error) {
            throw result.error;
          }
          response = result.response || response;
        } else {
          response = await __classPrivateFieldGet2(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
        }
      } finally {
        await logResponse(__classPrivateFieldGet2(this, _ClientSDK_logger, "f"), response, req).catch((e) => {
          var _a2;
          return (_a2 = __classPrivateFieldGet2(this, _ClientSDK_logger, "f")) == null ? void 0 : _a2.log("Failed to log response:", e);
        });
      }
      return response;
    }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK(r), (err) => {
      switch (true) {
        case isAbortError(err):
          return ERR(new RequestAbortedError("Request aborted by client", {
            cause: err
          }));
        case isTimeoutError(err):
          return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
        case isConnectionError(err):
          return ERR(new ConnectionError("Unable to make request", { cause: err }));
        default:
          return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
            cause: err
          }));
      }
    });
  }
};
_ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap();
var jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
var jsonlLikeContentTypeRE = /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
async function logRequest(logger, req) {
  if (!logger) {
    return;
  }
  const contentType = req.headers.get("content-type");
  const ct = (contentType == null ? void 0 : contentType.split(";")[0]) || "";
  logger.group(`> Request: ${req.method} ${req.url}`);
  logger.group("Headers:");
  for (const [k, v] of req.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct):
      logger.log(await req.clone().json());
      break;
    case ct.startsWith("text/"):
      logger.log(await req.clone().text());
      break;
    case ct === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}
async function logResponse(logger, res, req) {
  if (!logger) {
    return;
  }
  const contentType = res.headers.get("content-type");
  const ct = (contentType == null ? void 0 : contentType.split(";")[0]) || "";
  logger.group(`< Response: ${req.method} ${req.url}`);
  logger.log("Status Code:", res.status, res.statusText);
  logger.group("Headers:");
  for (const [k, v] of res.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().json());
      break;
    case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger.log(`<${contentType}>`);
      break;
    case matchContentType(res, "text/*"):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}

// node_modules/creem/dist/esm/sdk/sdk.js
var Creem = class extends ClientSDK {
  /**
   * Retrieve a product
   */
  async retrieveProduct(request, options) {
    return unwrapAsync(retrieveProduct(this, request, options));
  }
  /**
   * Creates a new product.
   */
  async createProduct(request, options) {
    return unwrapAsync(createProduct(this, request, options));
  }
  /**
   * List all products
   */
  async searchProducts(request, options) {
    return unwrapAsync(searchProducts(this, request, options));
  }
  /**
   * Retrieve a customer
   */
  async retrieveCustomer(request, options) {
    return unwrapAsync(retrieveCustomer(this, request, options));
  }
  /**
   * Generate Customer Links
   */
  async generateCustomerLinks(request, options) {
    return unwrapAsync(generateCustomerLinks(this, request, options));
  }
  /**
   * Retrieve a subscription
   */
  async retrieveSubscription(request, options) {
    return unwrapAsync(retrieveSubscription(this, request, options));
  }
  /**
   * Cancel a subscription.
   */
  async cancelSubscription(request, options) {
    return unwrapAsync(cancelSubscription(this, request, options));
  }
  /**
   * Update a subscription.
   */
  async updateSubscription(request, options) {
    return unwrapAsync(updateSubscription(this, request, options));
  }
  /**
   * Upgrade a subscription to a different product
   */
  async upgradeSubscription(request, options) {
    return unwrapAsync(upgradeSubscription(this, request, options));
  }
  /**
   * Retrieve a new checkout session.
   */
  async retrieveCheckout(request, options) {
    return unwrapAsync(retrieveCheckout(this, request, options));
  }
  /**
   * Creates a new checkout session.
   */
  async createCheckout(request, options) {
    return unwrapAsync(createCheckout(this, request, options));
  }
  /**
   * Activates a license key.
   */
  async activateLicense(request, options) {
    return unwrapAsync(activateLicense(this, request, options));
  }
  /**
   * Deactivate a license key instance.
   */
  async deactivateLicense(request, options) {
    return unwrapAsync(deactivateLicense(this, request, options));
  }
  /**
   * Validates a license key or instance.
   */
  async validateLicense(request, options) {
    return unwrapAsync(validateLicense(this, request, options));
  }
  /**
   * Retrieve discount
   */
  async retrieveDiscount(request, options) {
    return unwrapAsync(retrieveDiscount(this, request, options));
  }
  /**
   * Create a discount.
   */
  async createDiscount(request, options) {
    return unwrapAsync(createDiscount(this, request, options));
  }
  /**
   * Delete a discount.
   */
  async deleteDiscount(request, options) {
    return unwrapAsync(deleteDiscount(this, request, options));
  }
  /**
   * List all transactions
   */
  async searchTransactions(request, options) {
    return unwrapAsync(searchTransactions(this, request, options));
  }
};
export {
  Creem,
  SDK_METADATA,
  ServerList,
  files_exports as files,
  serverURLFromOptions
};
//# sourceMappingURL=creem.js.map
