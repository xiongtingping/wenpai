var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "crypto"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildAuthorization = exports.buildStringToSign = exports.buildSignature = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    function filter(value) {
        return typeof value === 'string'
            ? value.replace(/[\t\n\r\f]/g, ' ')
            : value.toString();
    }
    function getCanonicalizedHeaders(headers) {
        var keys = Object.keys(headers);
        var canonicalizedKeys = [];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key.startsWith('x-authing-') || key === 'date') {
                canonicalizedKeys.push(key);
            }
        }
        canonicalizedKeys.sort();
        var result = '';
        for (var i = 0; i < canonicalizedKeys.length; i++) {
            var key = canonicalizedKeys[i];
            result += "".concat(key, ":").concat(filter(headers[key]).trim(), "\n");
        }
        return result;
    }
    function getCanonicalizedResource(uriPattern, query) {
        var keys = Object.keys(query).sort();
        if (keys.length === 0) {
            return uriPattern;
        }
        var result = [];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = query[key];
            if (value === undefined) {
                continue;
            }
            value =
                typeof value === 'object' && value !== null
                    ? JSON.stringify(value)
                    : value;
            result.push("".concat(key, "=").concat(value));
        }
        return "".concat(uriPattern, "?").concat(result.join('&'));
    }
    /**
     * buildSignature
     * @param accessKeySecret
     * @param stringToSign
     * @returns
     */
    function buildSignature(accessKeySecret, stringToSign) {
        return crypto_1.default
            .createHmac('sha1', accessKeySecret)
            .update(Buffer.from(stringToSign, 'utf8'))
            .digest('base64');
    }
    exports.buildSignature = buildSignature;
    function buildStringToSign(method, uriPattern, headers, query) {
        var header = "".concat(method, "\n");
        var canonicalizedHeaders = getCanonicalizedHeaders(headers);
        var canonicalizedResource = getCanonicalizedResource(uriPattern, query);
        return "".concat(header).concat(canonicalizedHeaders).concat(canonicalizedResource);
    }
    exports.buildStringToSign = buildStringToSign;
    function buildAuthorization(accessKeyId, accessKeySecret, stringToSign) {
        return "".concat(accessKeyId, ":").concat(buildSignature(accessKeySecret, stringToSign));
    }
    exports.buildAuthorization = buildAuthorization;
});
//# sourceMappingURL=buildSignature.js.map